"""
Economic Center Module

This module implements the central economic system that manages all economic activities
in the agent-based economic simulation, including:

- Asset Management: Ledgers, products, labor hours, capital stocks
- Transaction Processing: Purchases, labor payments, taxes
- Tax System: Progressive income tax, corporate tax, VAT
- Firm Finances: Revenue, expenses, depreciation, innovation
- Job Market: Job postings, applications, matching
- Inventory Management: Reservations, stock tracking
- GDP Calculation: Production-based and expenditure-based GDP
- Government Operations: Tax collection and redistribution

Key Components:
    - EconomicCenter: Main class coordinating all economic activities
"""

import copy
import os
import random
import time
from collections import defaultdict
from typing import Any, Callable, Dict, List, Literal, Optional, Tuple, TYPE_CHECKING
from uuid import uuid4

import numpy as np
import ray
from dotenv import load_dotenv

from agenteconomy.center.Model import *
from agenteconomy.center.transaction import PeriodStatistics
from agenteconomy.utils.logger import get_logger
from agenteconomy.utils.product_attribute_loader import inject_product_attributes

# Avoid circular import by using TYPE_CHECKING
if TYPE_CHECKING:
    from agenteconomy.agent.firm import Firm
# Initialize environment and logger
load_dotenv()


# =============================================================================
# Economic Center Class
# =============================================================================

@ray.remote(num_cpus=8)
class EconomicCenter:

    # =========================================================================
    # Initialization
    # =========================================================================
    def __init__(self, tax_policy: TaxPolicy = None, category_profit_margins: Dict[str, float] = None):
        """
        Initialize EconomicCenter with tax rates
        
        Args:
            tax_policy: ç¨æ”¶æ”¿ç­–é…ç½®ï¼ˆåŒ…å«ç´¯è¿›ç¨é˜¶æ¢¯ï¼‰
            category_profit_margins: å„è¡Œä¸šæ¯›åˆ©ç‡é…ç½®
        """
        # Tax rate configuration - if not provided, use default value
        if tax_policy is None:
            tax_policy = TaxPolicy()  # Use default configuration
        
        self.income_tax_rate = tax_policy.income_tax_rate  # List[TaxBracket] - Progressive tax brackets
        self.vat_rate = tax_policy.vat_rate  # float - VAT rate
        self.corporate_tax_rate = tax_policy.corporate_tax_rate  # float - Corporate tax rate (fixed)
        self.logger = get_logger(name="economic_center")

        # ğŸ’° Product profit margin configuration (based on 12 major categories of Daily Category)
        # Generated by GPT-5, based on industryå®é™…æƒ…å†µå’Œå¸‚åœºç«äº‰ç¨‹åº¦
        # ğŸ”§ Fix: if None is passed, initialize default configuration (similar to SimulationConfig.__post_init__)
        if category_profit_margins is None:
            print('Using default profit margins')
            self.category_profit_margins = {
                "Beverages": 25.0,                              # Beverages
                "Confectionery and Snacks": 32.0,               # Confectionery and Snacks
                "Dairy Products": 15.0,                         # Dairy Products
                "Furniture and Home Furnishing": 30.0,          # Furniture and Home Furnishing
                "Garden and Outdoor": 28.0,                     # Garden and Outdoor
                "Grains and Bakery": 18.0,                      # Grains and Bakery
                "Household Appliances and Equipment": 30.0,     # Household Appliances and Equipment
                "Meat and Seafood": 16.0,                       # Meat and Seafood
                "Personal Care and Cleaning": 40.0,            # Personal Care and Cleaning
                "Pharmaceuticals and Health": 45.0,            # Pharmaceuticals and Health
                "Retail and Stores": 25.0,                      # Retail and Stores
                "Sugars, Oils, and Seasonings": 20.0,           # Sugars, Oils, and Seasonings
            }
        else:
            self.category_profit_margins = category_profit_margins

        # ===== Asset Storage =====
        # Save assets for different agents
        self.ledger: Dict[str, Ledger] = defaultdict(Ledger)
        self.products: Dict[str, List[Product]] = defaultdict(list)
        self.laborhour: Dict[str, List[LaborHour]] = defaultdict(list)

        # ===== Agent ID Registry =====
        # Save IDs for different agents
        self.government_id: List[str] = []  # government ID
        self.household_id: List[str] = []  #  household ID
        self.bank_id: List[str] = []  #  bank ID
        
        # ===== Transaction & Financial Tracking =====
        self.tx_history: List[Transaction] = []  # Store transaction history
        self.tx_by_month: Dict[int, List[Transaction]] = defaultdict(list)
        self.tx_by_type: Dict[str, List[Transaction]] = defaultdict(list)
        self.tx_by_party: Dict[str, List[Transaction]] = defaultdict(list)
        self.period_statistics: Dict[int, PeriodStatistics] = {}
        self.wage_history: List[Wage] = []
        self.firm_financials: Dict[str, Dict[str, float]] = defaultdict(lambda: {"total_income": 0.0, "total_expenses": 0.0})  # ä¼ä¸šè´¢åŠ¡è®°å½•
        self.firm_monthly_financials: Dict[str, Dict[int, Dict[str, float]]] = defaultdict(lambda: defaultdict(lambda: {"income": 0.0, "expenses": 0.0}))  # ä¼ä¸šæœˆåº¦è´¢åŠ¡è®°å½•
        self.firm_production_stats: Dict[str, Dict[int, Dict[str, float]]] = defaultdict(lambda: defaultdict(lambda: {"base_production": 0.0, "labor_production": 0.0}))  # ä¼ä¸šæœˆåº¦ç”Ÿäº§ç»Ÿè®¡
        # æœˆåº¦ç»†åˆ†ï¼šç”¨äºâ€œç°é‡‘æµå£å¾„â€çš„ç”Ÿäº§é¢„ç®—è®¡ç®—
        self.firm_monthly_wage_expenses: Dict[str, Dict[int, float]] = defaultdict(lambda: defaultdict(float))
        self.firm_monthly_corporate_tax: Dict[str, Dict[int, float]] = defaultdict(lambda: defaultdict(float))
        self.firm_monthly_production_cost: Dict[str, Dict[int, float]] = defaultdict(lambda: defaultdict(float))
        # åŠ³åŠ¨åŠ›ç”Ÿäº§çš„æ€»ä»·å€¼ï¼ˆæŒ‰é”€å”®ä»·æ ¼ä¼°å€¼ï¼‰ï¼Œç”¨äºç»Ÿè®¡è¾“å‡º
        self.firm_monthly_labor_production_value: Dict[str, Dict[int, float]] = defaultdict(lambda: defaultdict(float))
        # ä¼ä¸šç¨æœˆåº¦ç»“ç®—é˜²é‡ï¼ˆé¿å…é‡å¤æ‰£ç¨ï¼‰
        self._corporate_tax_settled_months: set[int] = set()
        self.redistribution_record_per_person:Dict[int, float] = defaultdict(float)
        # åˆ›æ–°ç³»ç»Ÿæ•°æ®ç»“æ„
        # ===== Innovation System =====
        self.firm_innovation_strategy: Dict[str, str] = {}  # {firm_id: "encouraged" or "suppressed"}
        self.firm_research_share: List[Dict[str, [float, int]]] = []  # [firm_id: [research_share, month]] ç ”å‘æŠ•å…¥æ¯”ä¾‹
        
        # åˆ›æ–°ç³»ç»Ÿæ•°æ®ç»“æ„
        self.firm_innovation_config: Dict[str, FirmInnovationConfig] = {}  # {firm_id: innovation_config}
        self.firm_innovation_events: List[FirmInnovationEvent] = []  # [firm_id: innovation_events, month: month] åˆ›æ–°äº‹ä»¶å†å²è®°å½•
        # âœ¨ åˆ›æ–°æ¨¡å—å¼€å…³ï¼ˆç”±ä»¿çœŸä¾§æ¯æœˆä¼ å…¥ innovation_config å†³å®šï¼›æœªå¼€å¯æ—¶åº”å¿½ç•¥åˆ›æ–°é…ç½®/äº‹ä»¶ï¼‰
        self.enable_innovation_module: bool = False
        
        # ğŸ”’ åº“å­˜é¢„ç•™ç³»ç»Ÿï¼ˆè§£å†³å¹¶å‘ç«äº‰é—®é¢˜ï¼‰
        # ===== Inventory Reservation System =====
        self.inventory_reservations: Dict[str, InventoryReservation] = {}  # {reservation_id: InventoryReservation}
        self.reservation_timeout: float = 300.0  # é»˜è®¤é¢„ç•™è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰= 5åˆ†é’Ÿ

        # ğŸ“‰ æœªæ»¡è¶³éœ€æ±‚ç»Ÿè®¡ï¼ˆç”¨äºâ€œç¼ºè´§â†’è¡¥è´§â€é—­ç¯ï¼‰
        # ç»“æ„ï¼š{month: {"product_id@firm_id": {"attempts": float, "qty_requested": float, "qty_short": float}}}
        # ===== Unmet Demand Tracking =====
        self.unmet_demand_by_month: Dict[int, Dict[str, Dict[str, float]]] = defaultdict(dict)

        # =========================
        # ğŸ¦ ä¼ä¸šèµ„äº§è´Ÿå€ºè¡¨ï¼ˆå›ºå®šèµ„äº§/ç°é‡‘ï¼‰ä¸æŠ˜æ—§ï¼ˆæ–°å¢ï¼‰
        # =========================
        # èµ„æœ¬å­˜é‡ï¼ˆbook value / ç”¨ä½œCD-Kï¼‰ï¼š{firm_id: capital_stock_value}
        # ===== Firm Capital & Depreciation =====
        self.firm_capital_stock: Dict[str, float] = defaultdict(float)
        # æœˆåº¦æŠ˜æ—§è´¹ç”¨ï¼ˆéç°é‡‘è´¹ç”¨ï¼‰ï¼š{firm_id: {month: depreciation_expense}}
        self.firm_monthly_depreciation: Dict[str, Dict[int, float]] = defaultdict(lambda: defaultdict(float))
        # æœˆåº¦èµ„æœ¬æŠ•èµ„ï¼ˆç°é‡‘â†’å›ºå®šèµ„äº§ï¼Œä¸è®¡å…¥å½“æœŸè´¹ç”¨ï¼‰ï¼š{firm_id: {month: capex_amount}}
        self.firm_monthly_capital_investment: Dict[str, Dict[int, float]] = defaultdict(lambda: defaultdict(float))
        # èµ„æœ¬å­˜é‡å†å²ï¼ˆä¾¿äºè°ƒè¯•/å¯¼å‡ºï¼‰ï¼š{firm_id: {month: capital_stock_end}}
        self.firm_capital_stock_history: Dict[str, Dict[int, float]] = defaultdict(lambda: defaultdict(float))
        


        # ===========new=========================
        self.firm: List['Firm'] = []  # Use string annotation to avoid circular import
        # Initialize log
        print(f"EconomicCenter initialized with tax policy:")
        print(f"  ğŸ“Š ä¸ªäººæ‰€å¾—ç¨: ç´¯è¿›ç¨åˆ¶ ({len(self.income_tax_rate)} æ¡£)")
        for i, bracket in enumerate(self.income_tax_rate):
            if i + 1 < len(self.income_tax_rate):
                print(f"     æ¡£ä½{i+1}: ${bracket.cutoff:>8,.0f} - ${self.income_tax_rate[i+1].cutoff:>8,.0f} â†’ {bracket.rate:>5.1%}")
            else:
                print(f"     æ¡£ä½{i+1}: ${bracket.cutoff:>8,.0f}+          â†’ {bracket.rate:>5.1%}")
        print(f"  ğŸ’¼ ä¼ä¸šæ‰€å¾—ç¨: {self.corporate_tax_rate:.1%} (å›ºå®šç¨ç‡)")
        print(f"  ğŸ›’ æ¶ˆè´¹ç¨(VAT): {self.vat_rate:.1%}")

        # =========================
        # ğŸ§® Month1 CD æ ¡å‡†ç»“æœï¼ˆç”±ä»¿çœŸä¾§å†™å…¥ï¼Œåç»­æœˆä»½æ²¿ç”¨ä¸å˜ï¼‰
        # =========================
        # ç»“æ„ä¸ simulation/joint_debug_test.py ä¸€è‡´
        # ===== CD Production Function Calibration =====
        self._cd_calibration: Dict[str, Any] = {}
        self._cd_industry_A: Dict[str, float] = {}
        self._cd_industry_K_tot: Dict[str, float] = {}
        self._cd_firm_K: Dict[str, float] = {}
        self._cd_firm_A: Dict[str, float] = {}

    def register_firm(self, firm: 'Firm'):
        """
        Register a firm in the economic center.
        
        Args:
            firm: Firm instance to register
        """
        # Import here to avoid circular import
        from agenteconomy.agent.firm import Firm as FirmType
        if not isinstance(firm, FirmType):
            raise TypeError(f"Expected Firm instance, got {type(firm)}")
        self.firm.append(firm)
        
    @staticmethod
    def _monthly_rate_from_annual(annual_rate: float) -> float:
        """
        Geometric conversion:
            r_m = 1 - (1 - r_a)^(1/12)
        """
        try:
            r = float(annual_rate or 0.0)
        except Exception:
            r = 0.0
        r = max(0.0, min(0.99, r))
        return float(1.0 - ((1.0 - r) ** (1.0 / 12.0)))


    # =========================================================================
    # Firm Asset Management (Capital & Inventory)
    # =========================================================================
    def register_firm_assets(self, allocations: Dict[str, Dict[str, float]], overwrite_cash: bool = True, overwrite_capital: bool = True) -> Dict[str, float]:
        """
        æ‰¹é‡æ³¨å†Œä¼ä¸šâ€œèµ„æœ¬å­˜é‡(K) + ç°é‡‘(Cash)â€ã€‚

        allocations:
            {firm_id: {"capital_stock": float, "cash": float}}
        """
        if not isinstance(allocations, dict):
            return {"firms_updated": 0, "capital_total": 0.0, "cash_total": 0.0}

        firms_updated = 0
        cap_total = 0.0
        cash_total = 0.0

        for cid, rec in allocations.items():
            firm_id = str(cid)
            if not firm_id:
                continue
            if firm_id not in self.ledger:
                self.ledger[firm_id] = Ledger.create(firm_id, 0.0)
            if firm_id not in self.firm_id:
                # ç¡®ä¿æ˜¯ä¼ä¸šIDï¼ˆé¿å…å› ä¸ºåˆå§‹åŒ–é¡ºåºå¯¼è‡´æ¼æ³¨å†Œï¼‰
                self.firm_id.append(firm_id)

            try:
                cap = float((rec or {}).get("capital_stock", 0.0) or 0.0)
            except Exception:
                cap = 0.0
            try:
                cash = float((rec or {}).get("cash", 0.0) or 0.0)
            except Exception:
                cash = 0.0

            if overwrite_capital:
                self.firm_capital_stock[firm_id] = max(0.0, cap)
            if overwrite_cash:
                self.ledger[firm_id].amount = float(cash)

            firms_updated += 1
            cap_total += max(0.0, cap)
            cash_total += cash

        return {"firms_updated": int(firms_updated), "capital_total": float(cap_total), "cash_total": float(cash_total)}

    def overwrite_product_amounts(
        self,
        inventory_by_firm: Dict[str, Dict[str, float]],
        set_unmentioned_to_zero: bool = False,
    ) -> Dict[str, Any]:
        """
        Overwrite inventory amounts for existing products.

        inventory_by_firm:
            {firm_id: {product_id: amount}}
        """
        if not isinstance(inventory_by_firm, dict):
            return {"firms_updated": 0, "products_updated": 0, "products_missing": 0}

        firms_updated = 0
        products_updated = 0
        products_missing = 0

        for cid, prod_map in (inventory_by_firm or {}).items():
            firm_id = str(cid or "")
            if not firm_id or not isinstance(prod_map, dict):
                continue

            if firm_id not in self.products:
                # Inventory overwrite assumes products are already registered for the firm
                self.products[firm_id] = []

            existing = {str(getattr(p, "product_id", "") or ""): p for p in (self.products.get(firm_id) or [])}

            touched = set()
            for pid, qty in (prod_map or {}).items():
                product_id = str(pid or "")
                if not product_id:
                    continue
                touched.add(product_id)
                try:
                    amount = float(qty or 0.0)
                except Exception:
                    amount = 0.0
                if amount < 0:
                    amount = 0.0

                if product_id in existing:
                    try:
                        existing[product_id].amount = amount
                        products_updated += 1
                    except Exception:
                        products_missing += 1
                else:
                    products_missing += 1

            if set_unmentioned_to_zero:
                for pid, p in existing.items():
                    if pid and pid not in touched:
                        try:
                            p.amount = 0.0
                            products_updated += 1
                        except Exception:
                            continue

            firms_updated += 1

        return {
            "firms_updated": int(firms_updated),
            "products_updated": int(products_updated),
            "products_missing": int(products_missing),
        }

    def query_firm_assets(self, firm_id: str) -> Dict[str, float]:
        cid = str(firm_id or "")
        if not cid:
            return {"capital_stock": 0.0, "cash_balance": 0.0, "net_assets": 0.0}
        if cid not in self.ledger:
            self.ledger[cid] = Ledger.create(cid, 0.0)
        capital = float(self.firm_capital_stock.get(cid, 0.0) or 0.0)
        cash = float(self.ledger[cid].amount or 0.0)
        return {"capital_stock": capital, "cash_balance": cash, "net_assets": float(capital + cash)}

    def query_all_firm_assets(self) -> Dict[str, Dict[str, float]]:
        result: Dict[str, Dict[str, float]] = {}
        for cid in list(self.firm_id or []):
            result[str(cid)] = self.query_firm_assets(str(cid))
        return result

    def invest_in_capital(self, firm_id: str, amount: float, month: int, allow_negative_cash: bool = True) -> Dict[str, float]:
        """
        Capital investment (capex):
        - Decrease firm cash balance (ledger) by `amount`
        - Increase firm capital stock K by `amount`
        - Record monthly capex for reporting

        Note: does NOT count as current-period expense (depreciation will amortize).
        """
        cid = str(firm_id or "")
        try:
            m = int(month or 0)
        except Exception:
            m = 0
        if not cid or m <= 0:
            return {"invested": 0.0, "capital_stock": 0.0, "cash_balance": 0.0}

        try:
            amt = float(amount or 0.0)
        except Exception:
            amt = 0.0
        if amt <= 0:
            assets = self.query_firm_assets(cid)
            assets["invested"] = 0.0
            return assets

        if cid not in self.ledger:
            self.ledger[cid] = Ledger.create(cid, 0.0)
        cash = float(self.ledger[cid].amount or 0.0)
        if (not allow_negative_cash) and cash < amt:
            amt = max(0.0, cash)
        if amt <= 0:
            assets = self.query_firm_assets(cid)
            assets["invested"] = 0.0
            return assets

        # Cash outflow
        self.ledger[cid].amount -= amt
        # Capital stock inflow
        k0 = float(self.firm_capital_stock.get(cid, 0.0) or 0.0)
        k1 = max(0.0, k0 + amt)
        self.firm_capital_stock[cid] = k1
        self.firm_capital_stock_history[cid][m] = k1
        self.firm_monthly_capital_investment[cid][m] += amt

        return {"invested": float(amt), "capital_stock": float(k1), "cash_balance": float(self.ledger[cid].amount or 0.0)}

    def apply_monthly_depreciation(self, month: int, annual_depreciation_rate: float = 0.08, reduce_capital_stock: bool = True) -> Dict[str, float]:
        """
        å¯¹æ‰€æœ‰ä¼ä¸šè®¡ææœˆåº¦æŠ˜æ—§ï¼š
        - æŠ˜æ—§è´¹ç”¨è®¡å…¥ firm_monthly_financials[month]["expenses"]ï¼ˆç”¨äºä¼ä¸šç¨åŸº/åˆ©æ¶¦å£å¾„ï¼‰
        - é»˜è®¤åŒæ—¶å‡å°‘ firm_capital_stockï¼ˆK_{t+1} = (1-Î´_m)K_tï¼‰
        """
        try:
            m = int(month or 0)
        except Exception:
            m = 0
        if m <= 0:
            return {"depreciation_total": 0.0, "firms": 0}

        r_m = self._monthly_rate_from_annual(annual_depreciation_rate)
        if r_m <= 0:
            return {"depreciation_total": 0.0, "firms": 0}

        total_dep = 0.0
        firms = 0
        for cid in list(self.firm_id or []):
            firm_id = str(cid)
            k0 = float(self.firm_capital_stock.get(firm_id, 0.0) or 0.0)
            if k0 <= 0:
                continue
            dep = float(k0 * r_m)
            if dep <= 1e-12:
                continue

            self.firm_monthly_depreciation[firm_id][m] += dep
            total_dep += dep
            firms += 1

            # è´¹ç”¨å‘ç”Ÿåˆ¶ï¼šæŠ˜æ—§è®¡å…¥æ”¯å‡ºï¼ˆä¸æ‰£ç°é‡‘ï¼‰
            self.record_firm_expense(firm_id, dep)
            self.record_firm_monthly_expense(firm_id, m, dep)

            if reduce_capital_stock:
                k1 = max(0.0, k0 - dep)
                self.firm_capital_stock[firm_id] = k1
                self.firm_capital_stock_history[firm_id][m] = k1
            else:
                self.firm_capital_stock_history[firm_id][m] = k0

        return {"depreciation_total": float(total_dep), "firms": int(firms), "monthly_rate": float(r_m)}

    def query_firm_monthly_depreciation(self, firm_id: str, month: int) -> float:
        try:
            m = int(month or 0)
        except Exception:
            m = 0
        if m <= 0:
            return 0.0
        return float(self.firm_monthly_depreciation.get(str(firm_id), {}).get(m, 0.0) or 0.0)

    def query_all_firms_monthly_depreciation(self, month: int) -> Dict[str, float]:
        try:
            m = int(month or 0)
        except Exception:
            m = 0
        if m <= 0:
            return {}
        return {str(cid): float(self.firm_monthly_depreciation.get(str(cid), {}).get(m, 0.0) or 0.0) for cid in list(self.firm_id or [])}

    @staticmethod
    def _unmet_key(product_id: str, seller_id: str) -> str:
        return f"{str(product_id)}@{str(seller_id)}"

    def record_unmet_demand(
        self,
        month: int,
        buyer_id: str,
        seller_id: str,
        product_id: str,
        product_name: str,
        quantity_requested: float,
        available_stock: float,
        reason: str = "reserve_failed",
    ) -> None:
        """
        è®°å½•â€œæœªæ»¡è¶³éœ€æ±‚â€ï¼ˆé¢„ç•™å¤±è´¥/åº“å­˜ä¸è¶³ï¼‰ã€‚

        qty_short = max(0, requested - available_stock)
        """
        try:
            m = int(month or 0)
            if m <= 0:
                return
            qty_req = max(0.0, float(quantity_requested or 0.0))
            avail = max(0.0, float(available_stock or 0.0))
            qty_short = max(0.0, qty_req - avail)
            if qty_req <= 0:
                return

            key = self._unmet_key(product_id, seller_id)
        # ===== Unmet Demand Tracking =====
            rec = (self.unmet_demand_by_month.get(m, {}) or {}).get(key)
            if rec is None:
                rec = {"attempts": 0.0, "qty_requested": 0.0, "qty_short": 0.0}
        # ===== Unmet Demand Tracking =====
                self.unmet_demand_by_month[m][key] = rec
            rec["attempts"] = float(rec.get("attempts", 0.0) or 0.0) + 1.0
            rec["qty_requested"] = float(rec.get("qty_requested", 0.0) or 0.0) + qty_req
            rec["qty_short"] = float(rec.get("qty_short", 0.0) or 0.0) + qty_short
        except Exception:
            return

    def query_unmet_demand(self, month: int) -> Dict[str, Dict[str, float]]:
        """æŸ¥è¯¢æŒ‡å®šæœˆä»½çš„æœªæ»¡è¶³éœ€æ±‚ç»Ÿè®¡ï¼ˆå¯åºåˆ—åŒ–ï¼‰ã€‚"""
        try:
            m = int(month or 0)
        except Exception:
            m = 0
        if m <= 0:
            return {}
        # ===== Unmet Demand Tracking =====
        return dict(self.unmet_demand_by_month.get(m, {}) or {})

    def set_cd_calibration(self, calibration: Dict[str, Any]) -> bool:
        """
        æ¥æ”¶å¹¶å›ºåŒ– month=1 çš„ CD æ ¡å‡†ç»“æœã€‚

        calibration ç»“æ„ï¼ˆå»ºè®®ï¼‰ï¼š
          - industry_A: {industry: A_s}
          - industry_K_tot: {industry: K_s_tot}
          - firm_K: {firm_id: K_i}
          - firm_w: {firm_id: w_i}
          - firm_A: {firm_id: A_i}  (å¯é€‰ï¼›è‹¥æ— åˆ™å›é€€ industry_A)
          - meta: {...}
        """
        try:
            if not isinstance(calibration, dict):
                return False
            self._cd_calibration = calibration
            self._cd_industry_A = dict(calibration.get("industry_A", {}) or {})
            self._cd_industry_K_tot = dict(calibration.get("industry_K_tot", {}) or {})
            self._cd_firm_K = dict(calibration.get("firm_K", {}) or {})
            self._cd_firm_A = dict(calibration.get("firm_A", {}) or {})
            self.logger.info(
                f"âœ… CDæ ¡å‡†ç»“æœå·²å†™å…¥EconomicCenter: industries={len(self._cd_industry_A)}, firms(K)={len(self._cd_firm_K)}, firms(A)={len(self._cd_firm_A)}"
            )
            return True
        except Exception as e:
            self.logger.error(f"å†™å…¥CDæ ¡å‡†ç»“æœå¤±è´¥: {e}")
            return False


    # =========================================================================
    # Agent Initialization
    # =========================================================================
    def init_agent_ledger(self, agent_id: str, initial_amount: float = 0.0):
        """
        Initialize a ledger for an agent with a given initial amount.
        If the agent already exists, it will not overwrite the existing ledger.
        """
        if agent_id not in self.ledger:
            ledger = Ledger.create(agent_id, amount=initial_amount)
            self.ledger[agent_id] = ledger
            # self.logger.info(f"Initialized ledger for agent {agent_id} with amount {initial_amount}")
    
    def init_agent_product(self, agent_id: str, product: Optional[Product]=None):
        """
        Initialize a product for an agent. If the product already exists, it will merge the amounts.
        """
        if agent_id not in self.products:
            # print(f"Initialized product for agent {agent_id}")
            self.products[agent_id] = []
        
        if product:
            self._add_or_merge_product(agent_id, product)
            # self.logger.info(f"Initialized product {product.name} for agent {agent_id} with amount {product.amount}")

    def init_agent_labor(self, agent_id:str, labor:[LaborHour]=[]):
        """
        Initialize the labor hour for an agent.
        """
        if agent_id not in self.laborhour:
            self.laborhour[agent_id] = []
        if labor:
            self.laborhour[agent_id] = labor

    def register_id(self, agent_id: str, agent_type: Literal['government', 'household', 'firm', 'bank']):
        """
        Register an agent ID based on its type.
        """
        if agent_type == 'government':
            self.government_id.append(agent_id)
        elif agent_type == 'household':
            self.household_id.append(agent_id)
        elif agent_type == 'firm':
            self.firm_id.append(agent_id)
        elif agent_type == 'bank':
            self.bank_id.append(agent_id)


    # =========================================================================
    # Query Methods
    # =========================================================================
    def query_all_products(self):
        return self.products

    def query_all_tx(self):
        return self.tx_history

    def set_all_firm_products_amount(self, amount: float) -> Dict[str, float]:
        """
        å°†æ‰€æœ‰ä¼ä¸šåä¸‹å•†å“åº“å­˜ amount è®¾ä¸ºç»Ÿä¸€å€¼ï¼ˆç”¨äºéœ€æ±‚é‡‡æ ·/å‹åŠ›æµ‹è¯•ï¼‰ã€‚

        Returns:
            {"products_updated": int, "amount": float}
        """
        try:
            amt = float(amount)
        except Exception:
            amt = 0.0
        if amt < 0:
            amt = 0.0
        updated = 0
        for owner_id, products in (self.products or {}).items():
            if owner_id not in (self.firm_id or []):
                continue
            for p in (products or []):
                try:
                    p.amount = amt
                    updated += 1
                except Exception:
                    continue
        return {"products_updated": int(updated), "amount": float(amt)}
    
    def query_exsiting_agents(self, agent_type: Literal['government', 'household', 'firm']) -> List[str]:
        """
        Query existing agents based on their type.
        """
        if agent_type == 'government':
            return self.government_id
        elif agent_type == 'household':
            return self.household_id
        elif agent_type == 'firm':
            return self.firm_id
        else:
            raise ValueError(f"Unknown agent type: {agent_type}")
        
    # query interface
    def query_balance(self, agent_id: str) -> float:
        """
        Query the cash balance of an agent.
        
        Args:
            agent_id: Unique identifier of the agent
            
        Returns:
            Current cash balance
        """
        if agent_id in self.ledger:
            return self.ledger[agent_id].amount
        else:
            return 0.0

    def query_redistribution_record_per_person(self, month: int) -> float:
        return self.redistribution_record_per_person[month]
    
    def query_products(self, agent_id: str) -> List[Product]:
        """
        Query all products owned by an agent.
        
        Args:
            agent_id: Unique identifier of the agent
            
        Returns:
            List of products owned by the agent
        """
        return self.products[agent_id]
    
    def query_price(self, agent_id: str, product_id: str) -> float:
        for product in self.products[agent_id]:
            if product.product_id == product_id:
                return product.price
        return 0.0
    
    def query_financial_summary(self, agent_id: str) -> Dict[str, float]:
        """æŸ¥è¯¢ä»£ç†çš„è´¢åŠ¡æ‘˜è¦ï¼šä½™é¢ã€æ€»æ”¶å…¥ã€æ€»æ”¯å‡ºï¼ˆä¼ä¸šé€‚ç”¨ï¼‰"""
        result = {}
        
        if agent_id in self.ledger:
            result["balance"] = self.ledger[agent_id].amount
        else:
            result["balance"] = 0.0
        
        # å¦‚æœæ˜¯ä¼ä¸šï¼Œæ·»åŠ æ”¶æ”¯è®°å½•
        if agent_id in self.firm_financials:
            result.update(self.firm_financials[agent_id])
            result["net_profit"] = result.get("total_income", 0.0) - result.get("total_expenses", 0.0)
        
        result['total_income'] = self.firm_financials[agent_id].get("total_income", 0.0)
        result['total_expenses'] = self.firm_financials[agent_id].get("total_expenses", 0.0)
        return result

    def get_transactions(
        self,
        month: Optional[int] = None,
        tx_type: Optional[str] = None,
        party_id: Optional[str] = None,
    ) -> List[Transaction]:
        if month is None and tx_type is None and party_id is None:
            return list(self.tx_history)

        base: List[Transaction]
        if month is not None:
            month = int(month)
            if month in self.tx_by_month:
                base = self.tx_by_month.get(month, []) or []
            else:
                base = self.tx_history
        elif party_id is not None:
            party_id = str(party_id)
            if party_id in self.tx_by_party:
                base = self.tx_by_party.get(party_id, []) or []
            else:
                base = self.tx_history
        elif tx_type is not None:
            tx_type = str(tx_type)
            if tx_type in self.tx_by_type:
                base = self.tx_by_type.get(tx_type, []) or []
            else:
                base = self.tx_history
        else:
            base = self.tx_history

        filtered = base
        if party_id is not None:
            party_id = str(party_id)
            filtered = [
                tx for tx in filtered
                if getattr(tx, "sender_id", None) == party_id or getattr(tx, "receiver_id", None) == party_id
            ]
        if month is not None:
            month = int(month)
            filtered = [tx for tx in filtered if int(getattr(tx, "month", 0) or 0) == month]
        if tx_type is not None:
            tx_type = str(tx_type)
            filtered = [tx for tx in filtered if str(getattr(tx, "type", "")) == tx_type]
        return filtered

    def get_transactions_by_receiver(
        self,
        receiver_id: str,
        tx_type: Optional[str] = None,
        month: Optional[int] = None,
    ) -> List[Dict]:
        """
        æŒ‰æ¥æ”¶æ–¹æŸ¥è¯¢äº¤æ˜“è®°å½•
        
        Args:
            receiver_id: æ¥æ”¶æ–¹ ID
            tx_type: äº¤æ˜“ç±»å‹ï¼ˆå¯é€‰ï¼‰
            month: æœˆä»½ï¼ˆå¯é€‰ï¼ŒNone è¡¨ç¤ºå…¨éƒ¨ï¼‰
            
        Returns:
            äº¤æ˜“è®°å½•åˆ—è¡¨ï¼Œæ¯æ¡è®°å½•ä¸ºå­—å…¸æ ¼å¼
        """
        filtered = []
        
        for tx in self.tx_history:
            # æ£€æŸ¥æ¥æ”¶æ–¹
            if getattr(tx, "receiver_id", None) != receiver_id:
                continue
            
            # æ£€æŸ¥äº¤æ˜“ç±»å‹
            if tx_type is not None and str(getattr(tx, "type", "")) != tx_type:
                continue
            
            # æ£€æŸ¥æœˆä»½
            if month is not None and int(getattr(tx, "month", 0) or 0) != int(month):
                continue
            
            # è½¬æ¢ä¸ºå­—å…¸æ ¼å¼
            filtered.append({
                "id": getattr(tx, "id", ""),
                "sender_id": getattr(tx, "sender_id", ""),
                "receiver_id": getattr(tx, "receiver_id", ""),
                "amount": float(getattr(tx, "amount", 0.0) or 0.0),
                "type": getattr(tx, "type", ""),
                "month": int(getattr(tx, "month", 0) or 0),
                "metadata": getattr(tx, "metadata", {}) or {},
            })
        
        return filtered

    def get_period_statistics(self, month: int) -> PeriodStatistics:
        month = int(month)
        if month in self.period_statistics:
            return self.period_statistics[month]

        self._get_period_stats(month)
        transactions = self.tx_by_month.get(month)
        if transactions is None:
            transactions = [tx for tx in self.tx_history if int(getattr(tx, "month", 0) or 0) == month]
        for tx in transactions:
            self._update_period_statistics(tx)
        return self.period_statistics[month]
    
    def record_firm_income(self, firm_id: str, amount: float):
        """è®°å½•ä¼ä¸šæ”¶å…¥"""
        self.firm_financials[firm_id]["total_income"] += amount
        
    def record_firm_expense(self, firm_id: str, amount: float):
        """è®°å½•ä¼ä¸šæ”¯å‡º"""
        self.firm_financials[firm_id]["total_expenses"] += amount
    
    def record_firm_monthly_income(self, firm_id: str, month: int, amount: float):
        """è®°å½•ä¼ä¸šæœˆåº¦æ”¶å…¥"""
        self.firm_monthly_financials[firm_id][month]["income"] += amount
        
    def record_firm_monthly_expense(self, firm_id: str, month: int, amount: float):
        """è®°å½•ä¼ä¸šæœˆåº¦æ”¯å‡º"""
        self.firm_monthly_financials[firm_id][month]["expenses"] += amount
    
    def query_firm_monthly_financials(self, firm_id: str, month: int) -> Dict[str, float]:
        """æŸ¥è¯¢ä¼ä¸šæŒ‡å®šæœˆä»½çš„è´¢åŠ¡æ•°æ®"""
        if firm_id in self.firm_monthly_financials and month in self.firm_monthly_financials[firm_id]:
            monthly_data = self.firm_monthly_financials[firm_id][month]
            depreciation = float(self.firm_monthly_depreciation.get(firm_id, {}).get(month, 0.0) or 0.0)
            return {
                "monthly_income": monthly_data["income"],
                "monthly_expenses": monthly_data["expenses"],
                "monthly_profit": monthly_data["income"] - monthly_data["expenses"],
                "monthly_depreciation": depreciation,
            }
        depreciation = float(self.firm_monthly_depreciation.get(firm_id, {}).get(month, 0.0) or 0.0)
        return {
            "monthly_income": 0.0,
            "monthly_expenses": 0.0,
            "monthly_profit": 0.0,
            "monthly_depreciation": depreciation,
        }

    def query_all_firms_monthly_financials(self, month: int) -> Dict[str, Dict[str, float]]:
        """
        æ‰¹é‡æŸ¥è¯¢â€œæ‰€æœ‰ä¼ä¸šâ€åœ¨æŒ‡å®šæœˆä»½çš„è´¢åŠ¡æ•°æ®ï¼ˆå‡å°‘Rayè¿œç¨‹è°ƒç”¨æ¬¡æ•°ï¼‰ã€‚

        Returns:
            {firm_id: {"monthly_income":..., "monthly_expenses":..., "monthly_profit":...}}
        """
        result: Dict[str, Dict[str, float]] = {}
        try:
            for cid in list(self.firm_id or []):
                data = self.firm_monthly_financials.get(cid, {}).get(month, None)
                if data:
                    inc = float(data.get("income", 0.0) or 0.0)
                    exp = float(data.get("expenses", 0.0) or 0.0)
                else:
                    inc = 0.0
                    exp = 0.0
                dep = float(self.firm_monthly_depreciation.get(str(cid), {}).get(month, 0.0) or 0.0)
                result[str(cid)] = {
                    "monthly_income": inc,
                    "monthly_expenses": exp,
                    "monthly_profit": inc - exp,
                    "monthly_depreciation": dep,
                }
        except Exception:
            # å…œåº•ï¼šè¿”å›å·²æ”¶é›†åˆ°çš„éƒ¨åˆ†ç»“æœ
            return result
        return result

    def query_firm_monthly_wage_expenses(self, firm_id: str, month: int) -> float:
        """
        æŸ¥è¯¢ä¼ä¸šæŒ‡å®šæœˆä»½çš„å·¥èµ„æ€»æ”¯å‡ºï¼ˆç¨å‰ gross_wageï¼‰ã€‚

        æ³¨æ„ï¼šå·¥èµ„åœ¨ process_labor ä¸­ä»¥ gross_wage è®¡å…¥ firm_monthly_wage_expensesï¼Œ
        ä¸ tx_history çš„ labor_paymentï¼ˆç¨åï¼‰ä¸åŒã€‚
        """
        try:
            return float(self.firm_monthly_wage_expenses.get(firm_id, {}).get(month, 0.0) or 0.0)
        except Exception:
            return 0.0
    
    def query_firm_production_stats(self, firm_id: str, month: int) -> Dict[str, float]:
        """æŸ¥è¯¢ä¼ä¸šæŒ‡å®šæœˆä»½çš„ç”Ÿäº§ç»Ÿè®¡æ•°æ®"""
        if firm_id in self.firm_production_stats and month in self.firm_production_stats[firm_id]:
            production_data = self.firm_production_stats[firm_id][month]
            return {
                "base_production": production_data["base_production"],
                "labor_production": production_data["labor_production"],
                "total_production": production_data["base_production"] + production_data["labor_production"]
            }
        return {"base_production": 0.0, "labor_production": 0.0, "total_production": 0.0}
    
    def query_firm_all_monthly_financials(self, firm_id: str) -> Dict[int, Dict[str, float]]:
        """æŸ¥è¯¢ä¼ä¸šæ‰€æœ‰æœˆä»½çš„è´¢åŠ¡æ•°æ®"""
        result = {}
        if firm_id in self.firm_monthly_financials:
            for month, data in self.firm_monthly_financials[firm_id].items():
                result[month] = {
                    "monthly_income": data["income"],
                    "monthly_expenses": data["expenses"],
                    "monthly_profit": data["income"] - data["expenses"]
                }
        return result

    def query_income(self, agent_id: str, month: int) -> float:
        total_wage = 0.0
        for wage in self.wage_history:
            if wage.agent_id == agent_id and wage.month == month:
                total_wage += wage.amount
        return total_wage

    def query_net_wage(self, household_id: str, month: int) -> float:
        """
        æŸ¥è¯¢å®¶åº­æŒ‡å®šæœˆä»½çš„â€œç¨åå·¥èµ„â€ï¼ˆæ¥è‡ª labor_payment äº¤æ˜“ï¼‰ã€‚

        è¯´æ˜ï¼š
        - wage_history è®°å½•çš„æ˜¯ç¨å‰å·¥èµ„ï¼ˆgrossï¼‰ï¼Œç”¨äºä¼ä¸šæˆæœ¬/å®è§‚æ ¸ç®—ï¼›
        - å®¶åº­å¯æ”¯é…æ”¶å…¥åº”ä»¥ labor_paymentï¼ˆnetï¼‰ä¸ºå‡†ï¼Œé¿å…æŠŠä¸ªç¨/FICAä¹Ÿå½“ä½œå¯æ¶ˆè´¹æ”¶å…¥ã€‚
        """
        total = 0.0
        try:
            transactions = self.tx_by_month.get(int(month))
            if transactions is None:
                transactions = self.tx_history
            for tx in transactions:
                if int(getattr(tx, "month", 0) or 0) != int(month):
                    continue
                if getattr(tx, "type", None) != "labor_payment":
                    continue
                if str(getattr(tx, "receiver_id", "") or "") != str(household_id):
                    continue
                total += float(getattr(tx, "amount", 0.0) or 0.0)
        except Exception:
            return 0.0
        return float(total)


    def query_labor(self, agent_id: str) -> List[LaborHour]:
        return self.laborhour[agent_id]

    def deposit_funds(self, agent_id: str, amount: float):
        """
        Deposit funds into an agent's ledger.
        
        Args:
            agent_id: Unique identifier of the agent
            amount: Amount to deposit
        """
        self.ledger[agent_id].amount += amount
    
    def set_agent_balance(self, agent_id: str, amount: float) -> float:
        """
        è®¾ç½®ä»£ç†ä½™é¢ä¸ºæŒ‡å®šå€¼ï¼ˆè¦†ç›–å¼ï¼‰ã€‚
        ç”¨äºâ€œä¼ä¸šåˆå§‹èµ„é‡‘ = åˆå§‹åº“å­˜æ€»ä»·å€¼â€ç­‰åˆå§‹åŒ–åœºæ™¯ã€‚
        """
        if agent_id not in self.ledger:
            self.ledger[agent_id] = Ledger()
        self.ledger[agent_id].amount = float(amount)
        return self.ledger[agent_id].amount
    
    def update_balance(self, agent_id: str, amount: float):
        """
        æ›´æ–°ä»£ç†çš„ä½™é¢ï¼ˆå¯ä»¥æ˜¯æ­£æ•°æˆ–è´Ÿæ•°ï¼‰
        
        Args:
            agent_id: ä»£ç†ID
            amount: å˜åŠ¨é‡‘é¢ï¼ˆæ­£æ•°å¢åŠ ï¼Œè´Ÿæ•°å‡å°‘ï¼‰
        """
        if agent_id not in self.ledger:
            self.ledger[agent_id] = Ledger()
        self.ledger[agent_id].amount += amount
    
    def consume_product_inventory(self, firm_id: str, product_id: str, quantity: float) -> bool:
        """
        å‡å°‘ä¼ä¸šå•†å“åº“å­˜
        
        Args:
            firm_id: ä¼ä¸šID
            product_id: å•†å“ID
            quantity: æ¶ˆè€—æ•°é‡
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸæ¶ˆè€—
        """
        if firm_id not in self.products:
            self.logger.warning(f"ä¼ä¸š {firm_id} æ²¡æœ‰äº§å“åº“å­˜")
            return False
        
        for product in self.products[firm_id]:
            if product.product_id == product_id:
                if product.amount >= quantity:
                    product.amount -= quantity
                    # self.logger.info(f"ä¼ä¸š {firm_id} å•†å“ {product_id} æ¶ˆè€— {quantity} å•ä½ï¼Œå‰©ä½™ {product.amount}")
                    return True
                else:
                    self.logger.warning(f"ä¼ä¸š {firm_id} å•†å“ {product_id} åº“å­˜ä¸è¶³: {product.amount} < {quantity}")
                    return False
        
        self.logger.warning(f"ä¼ä¸š {firm_id} æ²¡æœ‰æ‰¾åˆ°å•†å“ {product_id}")
        return False
    

    # =========================================================================
    # Product Management
    # =========================================================================
    def register_product(self, agent_id: str, product: Product):
        """
        Register a product for an agent. If the product already exists, it will merge the amounts.
        """
        if agent_id not in self.products:
            # print(f"Initialized product for agent {agent_id}")
            self.products[agent_id] = []
        
        self._add_or_merge_product(agent_id, product, product.amount)
        # self.logger.info(f"Registered product {product.name} for agent {agent_id} with amount {product.amount}")

    def _add_or_merge_product(self, agent_id:str, product: Product, quantity: float = 1.0):

        product.owner_id = agent_id
        product.amount = quantity
        for existing_product in self.products[agent_id]:
            if existing_product.product_id == product.product_id:
                existing_product.amount += quantity
                return
        self.products[agent_id].append(product)

    def _check_and_reserve_inventory(self, seller_id: str, product: Product, quantity: float) -> bool:
        """
        æ£€æŸ¥å¹¶é¢„ç•™åº“å­˜ï¼Œç¡®ä¿åŸå­æ€§è´­ä¹°æ“ä½œ
        è¿”å›Trueè¡¨ç¤ºåº“å­˜å……è¶³ä¸”å·²é¢„ç•™ï¼ŒFalseè¡¨ç¤ºåº“å­˜ä¸è¶³
        """
        if seller_id not in self.products:
            return False

        # ğŸ”’ å…¼å®¹é¢„ç•™ç³»ç»Ÿï¼šæ—  reservation_id çš„è´­ä¹°ä¹Ÿåº”è€ƒè™‘â€œå·²è¢«å…¶ä»–äººé¢„ç•™â€çš„æ•°é‡
        try:
            available_stock = self._get_available_stock(seller_id, product.product_id)
            return available_stock >= quantity
        except Exception:
            # å›é€€æ—§é€»è¾‘
            for existing_product in self.products[seller_id]:
                if existing_product.product_id == product.product_id:
                    return existing_product.amount >= quantity
            return False
    
    def _get_profit_margin(self, category: str) -> float:
        """
        æ ¹æ®å•†å“å¤§ç±»è·å–æ¯›åˆ©ç‡ï¼ˆç”¨äºåˆ©æ¶¦è®¡ç®—ï¼‰
        
        Args:
            category: å•†å“å¤§ç±»åç§°ï¼ˆdaily_cateï¼‰
            
        Returns:
            æ¯›åˆ©ç‡ï¼ˆç™¾åˆ†æ¯”ï¼Œå¦‚25.0è¡¨ç¤º25%ï¼‰
        """
        # å¦‚æœé…ç½®ä¸­æœ‰è¯¥å¤§ç±»ï¼Œè¿”å›é…ç½®çš„æ¯›åˆ©ç‡
        if category in self.category_profit_margins:
            return self.category_profit_margins[category]
        
        # å¦‚æœæ‰¾ä¸åˆ°è¯¥å¤§ç±»ï¼Œè¿”å›é»˜è®¤æ¯›åˆ©ç‡25%
        self.logger.warning(f"æœªæ‰¾åˆ°å¤§ç±» '{category}' çš„æ¯›åˆ©ç‡é…ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼25%")
        return 25.0

    def _ensure_product_cost_fields(self, product: Product, default_category: Optional[str] = None) -> None:
        """
        Ensure product has stable base_price and unit_cost.

        - base_price: original (initial) price used for cost derivation
        - unit_cost: derived from base_price and category gross margin (kept stable even if price changes)
        """
        try:
            current_price = float(getattr(product, "price", 0.0) or 0.0)
        except Exception:
            current_price = 0.0

        try:
            base_price = getattr(product, "base_price", None)
            base_price = float(base_price) if base_price is not None else 0.0
        except Exception:
            base_price = 0.0

        if base_price <= 0 and current_price > 0:
            product.base_price = current_price
            base_price = current_price

        try:
            unit_cost = getattr(product, "unit_cost", None)
            unit_cost = float(unit_cost) if unit_cost is not None else 0.0
        except Exception:
            unit_cost = 0.0

        if unit_cost <= 0 and base_price > 0:
            category = getattr(product, "classification", None) or default_category or "Unknown"
            try:
                margin_pct = float(self.category_profit_margins.get(category, 25.0) or 25.0)
            except Exception:
                margin_pct = 25.0
            margin_pct = max(0.0, min(80.0, margin_pct))
            unit_cost = base_price * (1.0 - margin_pct / 100.0)
            if unit_cost <= 1e-6:
                unit_cost = max(0.01, base_price * 0.2)
            product.unit_cost = float(unit_cost)
    
    def _reduce_or_remove_product(self, agent_id: str, product: Product, quantity: float = 1.0):
        """
        å‡å°‘å•†å“åº“å­˜ï¼ˆåœ¨ç¡®è®¤åº“å­˜å……è¶³åè°ƒç”¨ï¼‰
        """
        for existing_product in self.products[agent_id]:
            if existing_product.product_id == product.product_id:
                # å†æ¬¡æ£€æŸ¥åº“å­˜ï¼ˆåŒé‡ä¿é™©ï¼‰
                if existing_product.amount < quantity:
                    raise ValueError(f"åº“å­˜ä¸è¶³: éœ€è¦ {quantity}ï¼Œä½†åªæœ‰ {existing_product.amount}")
                
                existing_product.amount -= quantity
                return
        raise ValueError("Asset not found or insufficient amount to reduce.")
    
    # register_middleware
    def register_middleware(self, tx_type: str, middleware_fn: Callable[[Transaction, Dict[str, float]], None], tag: Optional[str] = None):
        """
        Register a middleware function for transaction processing.
        
        Args:
            tx_type: Type of transaction to apply middleware to
            middleware_fn: Middleware function to execute
            tag: Optional tag for identifying/replacing middleware
        """
        if tag:
            self.middleware.register(tx_type, middleware_fn, tag)
        else:
            self.middleware.register(tx_type, middleware_fn)
    
    # ============================================================================
    # ğŸ”’ åº“å­˜é¢„ç•™ç³»ç»Ÿï¼ˆè§£å†³å¹¶å‘ç«äº‰é—®é¢˜ï¼‰
    # ============================================================================
    

    # =========================================================================
    # Inventory Reservation System
    # =========================================================================
    def reserve_inventory(self, buyer_id: str, seller_id: str, product_id: str,
                         product_name: str, quantity: float,
                         timeout_seconds: float = None,
                         month: Optional[int] = None) -> Optional[str]:
        """
        é¢„ç•™åº“å­˜
        
        Args:
            buyer_id: ä¹°å®¶ID
            seller_id: å–å®¶ID
            product_id: å•†å“ID
            product_name: å•†å“åç§°
            quantity: é¢„ç•™æ•°é‡
            timeout_seconds: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ä½¿ç”¨ç³»ç»Ÿé…ç½®
        
        Returns:
            é¢„ç•™IDï¼ˆæˆåŠŸï¼‰æˆ– Noneï¼ˆå¤±è´¥ï¼‰
        """
        # æ¸…ç†è¿‡æœŸé¢„ç•™
        self._cleanup_expired_reservations()
        
        # æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³ï¼ˆè€ƒè™‘å·²é¢„ç•™çš„æ•°é‡ï¼‰
        available_stock = self._get_available_stock(seller_id, product_id)
        
        if available_stock < quantity:
            self.logger.warning(f"ğŸ”’ åº“å­˜é¢„ç•™å¤±è´¥: {product_name} å¯ç”¨åº“å­˜ {available_stock:.2f} < éœ€æ±‚ {quantity:.2f}")
            try:
                if month is not None:
                    self.record_unmet_demand(
                        month=int(month),
                        buyer_id=str(buyer_id),
                        seller_id=str(seller_id),
                        product_id=str(product_id),
                        product_name=str(product_name),
                        quantity_requested=float(quantity or 0.0),
                        available_stock=float(available_stock or 0.0),
                        reason="reserve_failed",
                    )
            except Exception:
                pass
            return None
        
        # åˆ›å»ºé¢„ç•™è®°å½•
        timeout = timeout_seconds if timeout_seconds is not None else self.reservation_timeout
        reservation = InventoryReservation.create(
            buyer_id=buyer_id,
            seller_id=seller_id,
            product_id=product_id,
            product_name=product_name,
            quantity=quantity,
            timeout_seconds=timeout
        )
        
        # ä¿å­˜é¢„ç•™è®°å½•
        # ===== Inventory Reservation System =====
        self.inventory_reservations[reservation.reservation_id] = reservation
        
        self.logger.info(f"âœ… åº“å­˜é¢„ç•™æˆåŠŸ: {product_name} Ã— {quantity:.2f} (é¢„ç•™ID: {reservation.reservation_id[:8]}...)")
        return reservation.reservation_id
    
    def confirm_reservation(self, reservation_id: str) -> bool:
        """
        ç¡®è®¤é¢„ç•™ï¼ˆè´­ä¹°æˆåŠŸåè°ƒç”¨ï¼‰
        
        Args:
            reservation_id: é¢„ç•™ID
        
        Returns:
            æ˜¯å¦æˆåŠŸç¡®è®¤
        """
        # ===== Inventory Reservation System =====
        if reservation_id not in self.inventory_reservations:
            self.logger.warning(f"âš ï¸ é¢„ç•™IDä¸å­˜åœ¨: {reservation_id[:8]}...")
            return False
        
        # ===== Inventory Reservation System =====
        reservation = self.inventory_reservations[reservation_id]

        # åªå…è®¸ç¡®è®¤â€œæ´»è·ƒâ€çš„é¢„ç•™ï¼Œé¿å…é‡å¤ç¡®è®¤/é”™è¯¯ç¡®è®¤
        if reservation.status != 'active':
            self.logger.warning(
                f"âš ï¸ é¢„ç•™çŠ¶æ€ä¸å¯ç¡®è®¤: {reservation.product_name} status={reservation.status} "
                f"(é¢„ç•™ID: {reservation_id[:8]}...)"
            )
            return False
        
        # æ£€æŸ¥é¢„ç•™æ˜¯å¦å·²è¿‡æœŸ
        if time.time() > reservation.expires_at:
            self.logger.warning(f"âš ï¸ é¢„ç•™å·²è¿‡æœŸ: {reservation.product_name} (é¢„ç•™ID: {reservation_id[:8]}...)")
            reservation.status = 'expired'
            return False
        
        # æ ‡è®°ä¸ºå·²ç¡®è®¤
        reservation.status = 'confirmed'
        self.logger.info(f"âœ… é¢„ç•™å·²ç¡®è®¤: {reservation.product_name} Ã— {reservation.quantity:.2f}")
        
        return True

    def validate_reservation(
        self,
        reservation_id: str,
        buyer_id: Optional[str] = None,
        seller_id: Optional[str] = None,
        product_id: Optional[str] = None,
        quantity: Optional[float] = None,
    ) -> bool:
        """
        æ ¡éªŒé¢„ç•™æ˜¯å¦å¯ç”¨äºæœ¬æ¬¡è´­ä¹°ï¼ˆä¸æ”¹å˜é¢„ç•™çŠ¶æ€ï¼‰ã€‚

        è¯´æ˜ï¼šé¢„ç•™åœ¨â€œå•†å“è½¬ç§»å®Œæˆåâ€æ‰ä¼šè¢« confirmï¼›åœ¨æ­¤ä¹‹å‰ä¿æŒ activeï¼Œ
        ä½¿å¾— _get_available_stock èƒ½æ­£ç¡®æ‰£é™¤å·²é¢„ç•™æ•°é‡ï¼Œé¿å…å¹¶å‘è¶…å–ã€‚
        """
        self._cleanup_expired_reservations()

        # ===== Inventory Reservation System =====
        if reservation_id not in self.inventory_reservations:
            self.logger.warning(f"âš ï¸ é¢„ç•™IDä¸å­˜åœ¨: {reservation_id[:8]}...")
            return False

        # ===== Inventory Reservation System =====
        reservation = self.inventory_reservations[reservation_id]
        if reservation.status != 'active':
            self.logger.warning(
                f"âš ï¸ é¢„ç•™ä¸å¯ç”¨: {reservation.product_name} status={reservation.status} "
                f"(é¢„ç•™ID: {reservation_id[:8]}...)"
            )
            return False

        if time.time() > reservation.expires_at:
            reservation.status = 'expired'
            self.logger.warning(f"âš ï¸ é¢„ç•™å·²è¿‡æœŸ: {reservation.product_name} (é¢„ç•™ID: {reservation_id[:8]}...)")
            return False

        if buyer_id is not None and reservation.buyer_id != buyer_id:
            self.logger.warning(f"âš ï¸ é¢„ç•™buyerä¸åŒ¹é…: expected={buyer_id} got={reservation.buyer_id}")
            return False
        if seller_id is not None and reservation.seller_id != seller_id:
            self.logger.warning(f"âš ï¸ é¢„ç•™sellerä¸åŒ¹é…: expected={seller_id} got={reservation.seller_id}")
            return False
        if product_id is not None and reservation.product_id != product_id:
            self.logger.warning(f"âš ï¸ é¢„ç•™productä¸åŒ¹é…: expected={product_id} got={reservation.product_id}")
            return False
        if quantity is not None and abs(float(reservation.quantity) - float(quantity)) > 1e-6:
            self.logger.warning(f"âš ï¸ é¢„ç•™quantityä¸åŒ¹é…: expected={quantity} got={reservation.quantity}")
            return False

        return True
    
    def release_reservation(self, reservation_id: str, reason: str = "cancelled") -> bool:
        """
        é‡Šæ”¾é¢„ç•™ï¼ˆè´­ä¹°å¤±è´¥æˆ–å–æ¶ˆæ—¶è°ƒç”¨ï¼‰
        
        Args:
            reservation_id: é¢„ç•™ID
            reason: é‡Šæ”¾åŸå› 
        
        Returns:
            æ˜¯å¦æˆåŠŸé‡Šæ”¾
        """
        # ===== Inventory Reservation System =====
        if reservation_id not in self.inventory_reservations:
            return False
        
        # ===== Inventory Reservation System =====
        reservation = self.inventory_reservations[reservation_id]
        reservation.status = 'released'
        
        self.logger.info(f"ğŸ”“ é¢„ç•™å·²é‡Šæ”¾: {reservation.product_name} Ã— {reservation.quantity:.2f} (åŸå› : {reason})")
        return True
    
    def _get_available_stock(self, seller_id: str, product_id: str) -> float:
        """
        è·å–å¯ç”¨åº“å­˜ï¼ˆå®é™…åº“å­˜ - å·²é¢„ç•™æ•°é‡ï¼‰
        
        Args:
            seller_id: å–å®¶ID
            product_id: å•†å“ID
        
        Returns:
            å¯ç”¨åº“å­˜æ•°é‡
        """
        # è·å–å®é™…åº“å­˜
        actual_stock = 0.0
        for product in self.products.get(seller_id, []):
            if product.product_id == product_id:
                actual_stock = product.amount
                break
        
        # è®¡ç®—å·²é¢„ç•™æ•°é‡ï¼ˆåªç»Ÿè®¡æ´»è·ƒçŠ¶æ€çš„é¢„ç•™ï¼‰
        reserved_quantity = 0.0
        # ===== Inventory Reservation System =====
        for reservation in self.inventory_reservations.values():
            if (reservation.seller_id == seller_id and
                reservation.product_id == product_id and
                reservation.status == 'active' and
                time.time() <= reservation.expires_at):
                reserved_quantity += reservation.quantity
        
        available = actual_stock - reserved_quantity
        return max(0.0, available)  # ç¡®ä¿ä¸è¿”å›è´Ÿæ•°
    
    def _cleanup_expired_reservations(self):
        """æ¸…ç†è¿‡æœŸçš„é¢„ç•™è®°å½•"""
        current_time = time.time()
        expired_ids = []
        
        # ===== Inventory Reservation System =====
        for reservation_id, reservation in self.inventory_reservations.items():
            if reservation.status == 'active' and current_time > reservation.expires_at:
                reservation.status = 'expired'
                expired_ids.append(reservation_id)
        
        if expired_ids:
            self.logger.info(f"ğŸ§¹ æ¸…ç†äº† {len(expired_ids)} ä¸ªè¿‡æœŸé¢„ç•™")
    
    def get_reservation_stats(self) -> Dict[str, int]:
        """è·å–é¢„ç•™ç»Ÿè®¡ä¿¡æ¯ï¼ˆç”¨äºç›‘æ§ï¼‰"""
        stats = {
        # ===== Inventory Reservation System =====
            'total': len(self.inventory_reservations),
            'active': 0,
            'confirmed': 0,
            'released': 0,
            'expired': 0
        }
        
        # ===== Inventory Reservation System =====
        for reservation in self.inventory_reservations.values():
            stats[reservation.status] += 1
        
        return stats
    

    # =========================================================================
    # Transaction Processing
    # =========================================================================
    def _ensure_ledger_entry(self, agent_id: str, initial_balance: float = 0.0) -> None:
        if agent_id not in self.ledger:
            self.ledger[agent_id] = Ledger.create(agent_id, float(initial_balance or 0.0))

    def _get_period_stats(self, month: int) -> PeriodStatistics:
        if month not in self.period_statistics:
            self.period_statistics[month] = PeriodStatistics(period=month)
        return self.period_statistics[month]

    def _index_transaction(self, tx: Transaction) -> None:
        try:
            month = int(getattr(tx, "month", 0) or 0)
        except Exception:
            month = 0

        self.tx_by_month[month].append(tx)
        tx_type = str(getattr(tx, "type", "unknown") or "unknown")
        self.tx_by_type[tx_type].append(tx)

        sender_id = getattr(tx, "sender_id", None)
        if sender_id:
            self.tx_by_party[str(sender_id)].append(tx)
        receiver_id = getattr(tx, "receiver_id", None)
        if receiver_id:
            self.tx_by_party[str(receiver_id)].append(tx)

    def _update_period_statistics(self, tx: Transaction) -> None:
        try:
            month = int(getattr(tx, "month", 0) or 0)
        except Exception:
            month = 0

        stats = self._get_period_stats(month)
        amount = float(getattr(tx, "amount", 0.0) or 0.0)
        tx_type = str(getattr(tx, "type", "") or "")

        stats.total_transactions += 1
        stats.total_volume += amount

        if tx_type in ("purchase", "product_sale", "inherent_market", "government_procurement"):
            stats.product_volume += amount
            if tx_type == "purchase" and getattr(tx, "sender_id", None) in self.household_id:
                stats.total_consumption += amount
        elif tx_type == "labor_payment":
            stats.wage_volume += amount
        elif tx_type == "resource_purchase":
            stats.resource_volume += amount
        elif tx_type in ("consume_tax", "labor_tax", "fica_tax", "corporate_tax", "tax_collection"):
            stats.tax_volume += amount

        if tx_type == "government_procurement":
            stats.total_government_spending += amount

    def _record_transaction(
        self,
        sender_id: str,
        receiver_id: str,
        amount: float,
        tx_type: str,
        month: int,
        assets: Optional[List[Any]] = None,
        labor_hours: Optional[List[LaborHour]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        related_transaction_id: Optional[str] = None,
        status: str = TransactionStatus.COMPLETED,
    ) -> Transaction:
        tx_kwargs = {
            "sender_id": sender_id,
            "receiver_id": receiver_id,
            "amount": float(amount or 0.0),
            "type": tx_type,
            "month": month,
            "status": status,
            "metadata": metadata or {},
        }
        if assets is not None:
            tx_kwargs["assets"] = assets
        if labor_hours is not None:
            tx_kwargs["labor_hours"] = labor_hours
        if related_transaction_id:
            tx_kwargs["related_transaction_id"] = related_transaction_id
        tx = Transaction(**tx_kwargs)
        self.tx_history.append(tx)
        self._index_transaction(tx)
        self._update_period_statistics(tx)
        return tx

    def record_intermediate_goods_purchase(
        self,
        month: int,
        buyer_id: str,
        total_cost: float,
        costs_by_industry: Optional[Dict[str, float]] = None,
        items: Optional[List[Dict[str, Any]]] = None,
        receiver_id: Optional[str] = None,
    ) -> Optional[str]:
        total_cost = float(total_cost or 0.0)
        if total_cost <= 0:
            return None

        if receiver_id is None:
            receiver_id = "market_intermediate_goods"

        self._ensure_ledger_entry(buyer_id)
        self._ensure_ledger_entry(receiver_id)

        is_company = buyer_id in self.firm_id
        if not is_company and self.ledger[buyer_id].amount < total_cost:
            raise ValueError(
                f"Insufficient balance for {buyer_id}: ${self.ledger[buyer_id].amount:.2f} < ${total_cost:.2f}"
            )
        elif is_company and self.ledger[buyer_id].amount < total_cost:
            self.self.logger.info(
                f"ğŸ’³ Company {buyer_id} intermediate goods purchase with negative balance: "
                f"${self.ledger[buyer_id].amount:.2f} â†’ ${self.ledger[buyer_id].amount - total_cost:.2f}"
            )

        self.ledger[buyer_id].amount -= total_cost
        self.ledger[receiver_id].amount += total_cost

        if is_company:
            self.record_firm_expense(buyer_id, total_cost)
            self.record_firm_monthly_expense(buyer_id, month, total_cost)
            self.firm_monthly_production_cost[buyer_id][month] += total_cost

        tx = self._record_transaction(
            sender_id=buyer_id,
            receiver_id=receiver_id,
            amount=total_cost,
            tx_type="product_sale",
            month=month,
            metadata={
                "purchase_category": "intermediate_goods",
                "costs_by_industry": costs_by_industry or {},
                "items": items or [],
            },
        )
        return tx.id

    def record_resource_purchase(
        self,
        month: int,
        buyer_id: str,
        industry_code: str,
        quantity: float,
        unit_price: float,
        total_cost: float,
        unit: Optional[str] = None,
        base_price: Optional[float] = None,
        receiver_id: Optional[str] = None,
    ) -> Optional[str]:
        total_cost = float(total_cost or 0.0)
        if total_cost <= 0:
            return None

        if receiver_id is None:
            receiver_id = f"market_resource_{industry_code}"

        self._ensure_ledger_entry(buyer_id)
        self._ensure_ledger_entry(receiver_id)

        is_company = buyer_id in self.firm_id
        if not is_company and self.ledger[buyer_id].amount < total_cost:
            raise ValueError(
                f"Insufficient balance for {buyer_id}: ${self.ledger[buyer_id].amount:.2f} < ${total_cost:.2f}"
            )
        elif is_company and self.ledger[buyer_id].amount < total_cost:
            self.self.logger.info(
                f"ğŸ’³ Company {buyer_id} resource purchase with negative balance: "
                f"${self.ledger[buyer_id].amount:.2f} â†’ ${self.ledger[buyer_id].amount - total_cost:.2f}"
            )

        self.ledger[buyer_id].amount -= total_cost
        self.ledger[receiver_id].amount += total_cost

        if is_company:
            self.record_firm_expense(buyer_id, total_cost)
            self.record_firm_monthly_expense(buyer_id, month, total_cost)
            self.firm_monthly_production_cost[buyer_id][month] += total_cost

        tx = self._record_transaction(
            sender_id=buyer_id,
            receiver_id=receiver_id,
            amount=total_cost,
            tx_type="resource_purchase",
            month=month,
            metadata={
                "industry_code": industry_code,
                "quantity": float(quantity or 0.0),
                "unit_price": float(unit_price or 0.0),
                "unit": unit,
                "base_price": base_price,
            },
        )
        return tx.id

    def process_batch_purchases(self, month: int, buyer_id: str, purchase_list: List[Dict]) -> List[Optional[str]]:
        """
        æ‰¹é‡å¤„ç†è´­ä¹°ï¼Œå‡å°‘Rayè¿œç¨‹è°ƒç”¨æ¬¡æ•°
        
        Args:
            month: å½“å‰æœˆä»½
            buyer_id: è´­ä¹°è€…ID
            purchase_list: è´­ä¹°åˆ—è¡¨ï¼Œæ¯é¡¹åŒ…å« {'seller_id', 'product', 'quantity', 'reservation_id'(å¯é€‰)}
        
        Returns:
            äº¤æ˜“IDåˆ—è¡¨ï¼ˆæˆåŠŸè¿”å›tx_idï¼Œå¤±è´¥è¿”å›Noneï¼‰
        """
        results = []
        for purchase in purchase_list:
            seller_id = purchase['seller_id']
            product = purchase['product']
            quantity = purchase.get('quantity', 1.0)
            reservation_id = purchase.get('reservation_id')  # ğŸ”’ æ–°å¢ï¼šé¢„ç•™ID
            
            tx_result = self.process_purchase(month, buyer_id, seller_id, product, quantity, reservation_id)
            
            # ğŸ”§ å¤„ç†è¿”å›å€¼ï¼šTransactionå¯¹è±¡æˆ–False
            if tx_result and hasattr(tx_result, 'id'):
                results.append(tx_result.id)  # è¿”å›äº¤æ˜“ID
            else:
                results.append(None)  # è´­ä¹°å¤±è´¥
        return results
    
    def process_purchase(self, month: int, buyer_id: str, seller_id: str, product: Product,
                         quantity: float = 1.0, reservation_id: Optional[str] = None) -> Optional[str]:
        """
        å¤„ç†è´­ä¹°äº¤æ˜“
        
        Args:
            month: å½“å‰æœˆä»½
            buyer_id: ä¹°å®¶ID
            seller_id: å–å®¶ID
            product: å•†å“å¯¹è±¡
            quantity: è´­ä¹°æ•°é‡
            reservation_id: é¢„ç•™IDï¼ˆå¦‚æœæœ‰ï¼‰
        
        Returns:
            Transactionå¯¹è±¡ï¼ˆæˆåŠŸï¼‰æˆ– Falseï¼ˆå¤±è´¥ï¼‰
        """
        # è®¡ç®—æ€»è´¹ç”¨ï¼šæ ‡ä»· + æ¶ˆè´¹ç¨
        base_price = product.price * quantity
        total_cost_with_tax = base_price * (1 + self.vat_rate)  # å®¶åº­æ”¯ä»˜æ ‡ä»·+æ¶ˆè´¹ç¨
        
        # æ£€æŸ¥å®¶åº­ä½™é¢æ˜¯å¦è¶³å¤Ÿæ”¯ä»˜å«ç¨ä»·æ ¼
        if self.ledger[buyer_id].amount < total_cost_with_tax:
            # å¦‚æœæœ‰é¢„ç•™ï¼Œé‡Šæ”¾å®ƒ
            if reservation_id:
                self.release_reservation(reservation_id, reason="insufficient_funds")
            return False

        # ğŸ”’ æ–°ç‰ˆåº“å­˜æ£€æŸ¥ï¼šä¼˜å…ˆä½¿ç”¨é¢„ç•™æœºåˆ¶ï¼ˆå…ˆæ ¡éªŒï¼Œä¸æ”¹å˜çŠ¶æ€ï¼›æˆåŠŸè½¬ç§»åå† confirmï¼‰
        if reservation_id:
            if not self.validate_reservation(
                reservation_id,
                buyer_id=buyer_id,
                seller_id=seller_id,
                product_id=getattr(product, "product_id", None),
                quantity=quantity,
            ):
                # å°½é‡é‡Šæ”¾æ— æ•ˆé¢„ç•™ï¼Œé¿å…â€œå¡æ­»åº“å­˜â€
                self.release_reservation(reservation_id, reason="invalid_reservation")
                self.logger.warning(f"é¢„ç•™æ— æ•ˆï¼Œè´­ä¹°å¤±è´¥: {product.name} (é¢„ç•™ID: {reservation_id[:8]}...)")
                return False
        else:
            # æ— é¢„ç•™IDï¼šä½¿ç”¨æ—§çš„æ£€æŸ¥æ–¹å¼ï¼ˆå‘åå…¼å®¹ï¼‰
            if not self._check_and_reserve_inventory(seller_id, product, quantity):
                # è·å–å½“å‰åº“å­˜ç”¨äºè°ƒè¯•
                current_stock = 0
                for pro in self.products.get(seller_id, []):
                    if pro.product_id == product.product_id:
                        current_stock = pro.amount
                        break
                self.logger.warning(f"åº“å­˜ä¸è¶³ï¼Œè´­ä¹°å¤±è´¥: {product.name} éœ€è¦ {quantity}ï¼Œä½†åº“å­˜ä¸è¶³, å‰©ä½™åº“å­˜: {current_stock}")
                try:
                    self.record_unmet_demand(
                        month=int(month),
                        buyer_id=str(buyer_id),
                        seller_id=str(seller_id),
                        product_id=str(getattr(product, "product_id", "")),
                        product_name=str(getattr(product, "name", "")),
                        quantity_requested=float(quantity or 0.0),
                        available_stock=float(current_stock or 0.0),
                        reason="purchase_no_reservation_insufficient_stock",
                    )
                except Exception:
                    pass
                return False

        # å®¶åº­æ”¯ä»˜å«ç¨ä»·æ ¼
        self.ledger[buyer_id].amount -= total_cost_with_tax

        # åˆ›å»ºæ¶ˆè´¹ç¨äº¤æ˜“è®°å½•ï¼ˆç¨æ”¶éƒ¨åˆ†ï¼‰
        tax_amount = base_price * self.vat_rate
        tax_tx = self._record_transaction(
            sender_id=buyer_id,
            receiver_id="gov_main_simulation",  # å›ºå®šæ”¿åºœID
            amount=tax_amount,
            tx_type='consume_tax',
            month=month,
            metadata={
                "tax_base": base_price,
                "tax_rate": self.vat_rate,
            },
        )
        
        # æ”¿åºœæ”¶å–æ¶ˆè´¹ç¨
        self.ledger["gov_main_simulation"].amount += tax_amount

        # åˆ›å»ºè´­ä¹°äº¤æ˜“è®°å½•ï¼ˆä¼ä¸šæ”¶å…¥éƒ¨åˆ†ï¼‰
        # ğŸ”§ äº¤æ˜“èµ„äº§å¿…é¡»æºå¸¦â€œæœ¬æ¬¡æˆäº¤æ•°é‡â€ï¼Œå¦åˆ™é”€å”®ç»Ÿè®¡ä¼šè¯¯è¯»ä¸ºâ€œå½“æ—¶åº“å­˜é‡â€
        try:
            tx_product_id = str(getattr(product, "product_id", "") or "")
            tx_name = str(getattr(product, "name", "Unknown") or "Unknown")
            tx_classification = getattr(product, "classification", None) or "Unknown"
            tx_price = float(getattr(product, "price", 0.0) or 0.0)
            tx_base_price = float(getattr(product, "base_price", 0.0) or 0.0)
            tx_unit_cost = float(getattr(product, "unit_cost", 0.0) or 0.0)

            if seller_id in self.products and tx_product_id:
                for inv_p in (self.products.get(seller_id) or []):
                    if str(getattr(inv_p, "product_id", "") or "") == tx_product_id:
                        self._ensure_product_cost_fields(inv_p, default_category=tx_classification)
                        tx_name = str(getattr(inv_p, "name", tx_name) or tx_name)
                        tx_classification = getattr(inv_p, "classification", tx_classification) or tx_classification
                        tx_base_price = float(getattr(inv_p, "base_price", tx_base_price) or tx_base_price)
                        tx_unit_cost = float(getattr(inv_p, "unit_cost", tx_unit_cost) or tx_unit_cost)
                        break

            if tx_base_price <= 0 and tx_price > 0:
                tx_base_price = tx_price
            if tx_unit_cost <= 0 and tx_base_price > 0:
                margin_pct = float(self.category_profit_margins.get(tx_classification, 25.0) or 25.0)
                margin_pct = max(0.0, min(80.0, margin_pct))
                tx_unit_cost = tx_base_price * (1.0 - margin_pct / 100.0)
                if tx_unit_cost <= 1e-6:
                    tx_unit_cost = max(0.01, tx_base_price * 0.2)

            product_kwargs = dict(
                asset_type="products",
                product_id=tx_product_id,
                name=tx_name,
                owner_id=seller_id,
                amount=float(quantity or 0.0),
                price=tx_price,
                classification=tx_classification,
                base_price=float(tx_base_price),
                unit_cost=float(tx_unit_cost),
            )
            product_kwargs = inject_product_attributes(product_kwargs, tx_product_id)
            product_asset = Product(**product_kwargs)
        except Exception:
            # å…œåº•ï¼šè‡³å°‘ä¿è¯ amount=quantityï¼Œé¿å…é”€é‡ç»Ÿè®¡çˆ†ç‚¸
            product_asset = Product.create(
                name=str(getattr(product, "name", "Unknown") or "Unknown"),
                price=float(getattr(product, "price", 0.01) or 0.01),
                owner_id=seller_id,
                amount=float(quantity or 0.0),
                classification=getattr(product, "classification", None),
                product_id=getattr(product, "product_id", None),
                base_price=getattr(product, "base_price", None),
                unit_cost=getattr(product, "unit_cost", None),
            )

        purchase_tx = self._record_transaction(
            sender_id=buyer_id,
            receiver_id=seller_id,
            amount=base_price,
            assets=[product_asset],
            tx_type='purchase',
            month=month,
            metadata={
                "product_id": getattr(product_asset, "product_id", None),
                "quantity": float(quantity or 0.0),
                "unit_price": float(getattr(product_asset, "price", 0.0) or 0.0),
                "reservation_id": reservation_id,
            },
        )

        # ğŸ’° ä¼ä¸šæ”¶å…¥ï¼ˆç°é‡‘æµå£å¾„ï¼‰ï¼šåªè®°å½•çœŸå®æ”¶æ¬¾é¢
        # è¯´æ˜ï¼šç”Ÿäº§æˆæœ¬åº”åœ¨â€œç”Ÿäº§è¡¥è´§é˜¶æ®µâ€ä½œä¸ºå½“æœˆæ”¯å‡ºè®°å½•ï¼Œè€Œä¸æ˜¯åœ¨é”€å”®å‘ç”Ÿæ—¶æ‰£é™¤ã€‚
        revenue = base_price
        self.ledger[seller_id].amount += revenue
        self.record_firm_income(seller_id, revenue)
        self.record_firm_monthly_income(seller_id, month, revenue)
        
        # ä¼ä¸šæ‰€å¾—ç¨æ”¹ä¸ºâ€œæœˆåº¦ç»“ç®—â€ï¼ˆæŒ‰å‡€åˆ©æ¶¦è®¡ç¨ï¼‰ï¼Œé¿å…ä¸ç”Ÿäº§é¢„ç®—å½¢æˆå¾ªç¯ä¾èµ–ã€‚
        
        # å•†å“è½¬ç§»
        try:
            self._add_or_merge_product(buyer_id, product, quantity)
            self._reduce_or_remove_product(seller_id, product, quantity)
        except Exception as e:
            if reservation_id:
                self.release_reservation(reservation_id, reason="transfer_failed")
            print(f"Warning: Failed to process purchase: {e}")
            return False

        # ğŸ”’ æˆåŠŸå®Œæˆå•†å“è½¬ç§»åï¼Œç¡®è®¤é¢„ç•™
        if reservation_id:
            self.confirm_reservation(reservation_id)
        
        return purchase_tx

    def process_wage(
        self,
        month: int,
        wage_hour: float,
        household_id: str,
        firm_id: str,
        hours_per_period: float = 40.0,
        periods_per_month: float = 4.0,
    ) -> str:
        """
        å‘æ”¾å·¥èµ„ï¼ˆå«ç¨æ”¶æ‹†åˆ†ï¼‰

        å£å¾„ï¼š
        - ç¨å‰å·¥èµ„ w = wage_hour Ã— hours_per_period Ã— periods_per_month
          å…¶ä¸­ hours_per_period é»˜è®¤ä¸ºæ¯å‘¨40å°æ—¶ï¼Œperiods_per_month é»˜è®¤ä¸º4ï¼ˆæŒ‰æœˆæŠ˜ç®—ï¼‰
        - ä¸ªäººæ‰€å¾—ç¨ï¼šæ²¿ç”¨æ—¢æœ‰çš„ç´¯è¿›ç¨è®¡ç®—ï¼ˆcalculate_progressive_income_taxï¼‰
        - æ–°å¢ FICAï¼šæŒ‰ w çš„ 7.65% è®¡ç®—ï¼Œç›´æ¥è½¬ç»™æ”¿åºœ
        """
        # è®¡ç®—ç¨å‰å·¥èµ„ï¼ˆwï¼‰
        try:
            hours = float(hours_per_period or 0.0)
        except Exception:
            hours = 0.0
        try:
            ppm = float(periods_per_month or 0.0)
        except Exception:
            ppm = 0.0
        hours = max(0.0, hours)
        ppm = max(0.0, ppm)
        gross_wage = float(wage_hour or 0.0) * hours * ppm
        
        # è®¡ç®—ä¸ªäººæ‰€å¾—ç¨
        income_tax = self.calculate_progressive_income_tax(gross_wage)

        # æ–°å¢ï¼šFICAï¼ˆæŒ‰ç¨å‰å·¥èµ„æ¯”ä¾‹ï¼‰
        fica_tax_rate = 0.0765
        fica_tax = float(gross_wage) * float(fica_tax_rate)

        net_wage = gross_wage - income_tax - fica_tax  # ç¨åå·¥èµ„ï¼ˆæ‰£ä¸ªç¨+FICAï¼‰
        if net_wage < 0:
            net_wage = 0.0
        
        # åˆ›å»ºå·¥èµ„æ”¯ä»˜äº¤æ˜“è®°å½•
        wage_tx = self._record_transaction(
            sender_id=firm_id,
            receiver_id=household_id,
            amount=net_wage,  # å®¶åº­æ”¶åˆ°ç¨åå·¥èµ„
            tx_type='labor_payment',
            month=month,
            metadata={
                "gross_wage": gross_wage,
                "net_wage": net_wage,
                "income_tax": income_tax,
                "fica_tax": fica_tax,
                "wage_hour": wage_hour,
                "hours_per_period": hours,
                "periods_per_month": ppm,
            },
        )
        
        # åˆ›å»ºä¸ªäººæ‰€å¾—ç¨äº¤æ˜“è®°å½•
        tax_tx = self._record_transaction(
            sender_id=household_id,
            receiver_id="gov_main_simulation",
            amount=income_tax,
            tx_type='labor_tax',
            month=month,
            metadata={
                "gross_wage": gross_wage,
                "tax_rate": (income_tax / gross_wage) if gross_wage > 0 else 0.0,
            },
        )
        
        # åˆ›å»º FICA ç¨äº¤æ˜“è®°å½•
        fica_tx = self._record_transaction(
            sender_id=household_id,
            receiver_id="gov_main_simulation",
            amount=fica_tax,
            tx_type='fica_tax',
            month=month,
            metadata={
                "gross_wage": gross_wage,
                "tax_rate": fica_tax_rate,
            },
        )

        # æ›´æ–°è´¦æœ¬
        self.ledger[household_id].amount += net_wage  # å®¶åº­æ”¶åˆ°ç¨åå·¥èµ„
        self.ledger["gov_main_simulation"].amount += income_tax  # æ”¿åºœæ”¶åˆ°ä¸ªäººæ‰€å¾—ç¨
        self.ledger["gov_main_simulation"].amount += fica_tax  # æ”¿åºœæ”¶åˆ°FICAç¨
        
        # ä¼ä¸šæ”¯å‡ºå·¥èµ„
        if firm_id:
            self.ledger[firm_id].amount -= gross_wage
            # è®°å½•ä¼ä¸šæ”¯å‡ºï¼ˆç»æµä¸­å¿ƒå±‚é¢ï¼‰
            self.record_firm_expense(firm_id, gross_wage)
            # è®°å½•ä¼ä¸šæœˆåº¦æ”¯å‡º
            self.record_firm_monthly_expense(firm_id, month, gross_wage)
            # ç»†åˆ†ç»Ÿè®¡ï¼šæœˆåº¦å·¥èµ„æ”¯å‡ºï¼ˆç¨å‰å·¥èµ„ï¼‰
            self.firm_monthly_wage_expenses[firm_id][month] += gross_wage

        # è®°å½•å·¥èµ„å†å²ï¼ˆè®°å½•ç¨å‰å·¥èµ„ï¼‰
        self.wage_history.append(Wage.create(household_id, gross_wage, month))
        # print(f"Month {month} Processed labor payment: ${gross_wage:.2f} gross (${net_wage:.2f} net, ${income_tax:.2f} tax) from {firm_id} to {household_id}")
        return wage_tx.id


    # =========================================================================
    # Tax Calculations
    # =========================================================================
    def calculate_progressive_income_tax(self, gross_wage: float) -> float:
        """
        Calculate the income tax for a given gross wage
        """
        total_tax = 0
        for i, bracket in enumerate(self.income_tax_rate):
            if gross_wage > bracket.cutoff:
                if i + 1 < len(self.income_tax_rate):
                    upper_bracket = self.income_tax_rate[i + 1].cutoff
                else:
                    upper_bracket = float('inf')
                taxable_in_bracket = min(gross_wage, upper_bracket) - bracket.cutoff
                total_tax += taxable_in_bracket * bracket.rate
            else:
                break
        return total_tax

    def compute_household_settlement(self, household_id: str):
        """
        Process household settlement, including asset and labor hour settlement.
        è®¡ç®—å®¶åº­ç´¯ç§¯æ”¶å…¥å’Œæ”¯å‡º
        """
        household_key = str(household_id)

        total_income = 0
        total_expense = 0
        transactions = self.tx_by_party.get(household_key)
        if transactions is None:
            transactions = self.tx_history
        for tx in transactions:
            if tx.type == 'purchase' and tx.sender_id == household_key:
                total_expense += tx.amount

            elif tx.type == 'service' and tx.sender_id == household_key:
                total_expense += tx.amount  # æœåŠ¡è´¹ç”¨ç›´æ¥è®¡å…¥æ”¯å‡ºï¼Œä¸éœ€è¦ç¨æ”¶è°ƒæ•´

            elif tx.type == 'labor_payment' and tx.receiver_id == household_key:
                total_income += tx.amount

            elif tx.type == 'redistribution' and tx.receiver_id == household_key:
                total_income += tx.amount

            elif tx.type == 'interest' and tx.receiver_id == household_key:
                total_income += tx.amount

        return total_income, total_expense

    def compute_household_monthly_stats(self, household_id: str, target_month: int = None):
        """
        è®¡ç®—å®¶åº­æœˆåº¦æ”¶å…¥å’Œæ”¯å‡ºç»Ÿè®¡(æ”¶å…¥ä¸ç»Ÿè®¡å†åˆ†é…)
        å¦‚æœä¸æŒ‡å®štarget_monthï¼Œè¿”å›æ‰€æœ‰æœˆä»½çš„ç»Ÿè®¡
        """
        household_key = str(household_id)
        monthly_income = 0
        monthly_expense = 0
        
        month = target_month


        transactions = self.tx_by_party.get(household_key)
        if transactions is None:
            transactions = self.tx_history
        for tx in transactions:
            if tx.type == 'purchase' and tx.sender_id == household_key and tx.month == month:
                monthly_expense += tx.amount
            # æ¶ˆè´¹ç¨å±äºâ€œå«ç¨è´­ç‰©æ”¯å‡ºâ€çš„ä¸€éƒ¨åˆ†ï¼ˆå®¶åº­çœŸå®ç°é‡‘æµæ”¯å‡ºï¼‰
            elif tx.type == 'consume_tax' and tx.sender_id == household_key and tx.month == month:
                monthly_expense += tx.amount

            elif tx.type == 'service' and tx.sender_id == household_key and tx.month == month:
                monthly_expense += tx.amount

            elif tx.type == 'labor_payment' and tx.receiver_id == household_key and tx.month == month:
                monthly_income += tx.amount

            elif tx.type == 'interest' and tx.receiver_id == household_key and tx.month == month:
                monthly_income += tx.amount

            # elif tx.type == 'redistribution' and tx.receiver_id == household_id and tx.month == month:
            #     monthly_income += tx.amount

        return monthly_income, monthly_expense, self.ledger[household_id].amount
    

    # =========================================================================
    # Tax Collection & Redistribution
    # =========================================================================
    def get_monthly_tax_collection(self, month: int) -> Dict[str, float]:
        """
        è·å–æŒ‡å®šæœˆä»½çš„ç¨æ”¶æ”¶å…¥ç»Ÿè®¡
        
        Args:
            month: ç›®æ ‡æœˆä»½
            
        Returns:
            Dict: å„ç±»ç¨æ”¶æ”¶å…¥ç»Ÿè®¡
        """
        tax_summary = {
            "consume_tax": 0.0,
            "labor_tax": 0.0,
            "fica_tax": 0.0,
            "corporate_tax": 0.0,
            "total_tax": 0.0
        }
        
        transactions = self.tx_by_month.get(month)
        if transactions is None:
            transactions = self.tx_history
        for tx in transactions:
            if tx.month == month and tx.receiver_id == "gov_main_simulation":
                if tx.type == 'consume_tax':
                    tax_summary["consume_tax"] += tx.amount
                elif tx.type == 'labor_tax':
                    tax_summary["labor_tax"] += tx.amount
                elif tx.type == 'fica_tax':
                    tax_summary["fica_tax"] += tx.amount
                elif tx.type == 'corporate_tax':
                    tax_summary["corporate_tax"] += tx.amount
        
        tax_summary["total_tax"] = (tax_summary["consume_tax"] +
                                   tax_summary["labor_tax"] +
                                   tax_summary["fica_tax"] +
                                   tax_summary["corporate_tax"])
        
        return tax_summary
    

    async def redistribute_monthly_taxes(self, month: int, strategy: str = "equal",
                                       poverty_weight: float = 0.3,
                                       unemployment_weight: float = 0.2,
                                       family_size_weight: float = 0.1) -> Dict[str, float]:
        """
        ç¨æ”¶å†åˆ†é…ï¼šæ”¯æŒå¤šç§åˆ†é…ç­–ç•¥
        
        Args:
            month: å½“å‰æœˆä»½
            strategy: åˆ†é…ç­–ç•¥ ("none", "equal", "income_proportional", "poverty_focused", "unemployment_focused", "family_size", "mixed")
            poverty_weight: è´«å›°æƒé‡ (0-1)
            unemployment_weight: å¤±ä¸šæƒé‡ (0-1)
            family_size_weight: å®¶åº­è§„æ¨¡æƒé‡ (0-1)
            
        Returns:
            Dict: å†åˆ†é…ç»“æœç»Ÿè®¡
        """
        # å¦‚æœç­–ç•¥ä¸º "none"ï¼Œä¸è¿›è¡Œå†åˆ†é…
        if strategy == "none":
            tax_summary = self.get_monthly_tax_collection(month)
            return {
                "total_redistributed": 0.0,
                "recipients": 0,
                "per_person": 0.0,
                "total_tax_collected": tax_summary["total_tax"],
                "tax_breakdown": tax_summary
            }
        
        # è·å–å½“æœˆç¨æ”¶æ€»é¢
        tax_summary = self.get_monthly_tax_collection(month)
        total_tax = tax_summary["total_tax"]
        
        if total_tax <= 0:
            print(f"Month {month}: No tax revenue to redistribute")
            return {"total_redistributed": 0.0, "recipients": 0, "per_person": 0.0}
        
        # è·å–æ‰€æœ‰æœ‰åŠ³åŠ¨åŠ›çš„å®¶åº­IDï¼ˆåŸºäºç°æœ‰çš„laborhourå­—å…¸ï¼‰
        all_workers = [household_id for household_id, labor_hours in self.laborhour.items()
                      if labor_hours]  # åªåŒ…æ‹¬æœ‰åŠ³åŠ¨åŠ›çš„å®¶åº­
        if not all_workers:
            print(f"Month {month}: No households with labor hours found for tax redistribution")
            return {"total_redistributed": 0.0, "recipients": 0, "per_person": 0.0}
        
        # æ ¹æ®ç­–ç•¥è®¡ç®—åˆ†é…é‡‘é¢
        household_allocations = self._calculate_redistribution_allocations(
            all_workers, total_tax, strategy, poverty_weight, unemployment_weight, family_size_weight, month
        )
        
        total_redistributed = 0.0
        successful_redistributions = 0
        
        # æ‰§è¡Œå†åˆ†é…
        for household_id, allocation_amount in household_allocations.items():
            try:
                if allocation_amount > 0:
                    # æ”¿åºœå‘å®¶åº­è½¬è´¦
                    tx_id = self.add_redistribution_tx(
                        month=month,
                        sender_id="gov_main_simulation",
                        receiver_id=household_id,
                        amount=allocation_amount,
                    )
                    
                    total_redistributed += allocation_amount
                    successful_redistributions += 1
        
            except Exception as e:
                print(f"Failed to redistribute to household {household_id}: {e}")

        # è®¡ç®—å¹³å‡åˆ†é…é‡‘é¢ï¼ˆç”¨äºè®°å½•ï¼‰
        avg_allocation = total_redistributed / successful_redistributions if successful_redistributions > 0 else 0
        
        result = {
            "total_tax_collected": total_tax,
            "total_redistributed": total_redistributed,
            "recipients": successful_redistributions,
            "per_person": avg_allocation,
            "strategy": strategy,
            "tax_breakdown": tax_summary
        }
        self.redistribution_record_per_person[month] = avg_allocation

        print(f"Month {month} Tax Redistribution ({strategy}):")
        print(f"  Total tax collected: ${total_tax:.2f}")
        print(f"  Redistributed to {successful_redistributions} households: ${total_redistributed:.2f}")
        print(f"  Average per household: ${avg_allocation:.2f}")
        
        return result

    def _calculate_redistribution_allocations(self, all_workers: List[str], total_tax: float,
                                           strategy: str, poverty_weight: float,
                                           unemployment_weight: float, family_size_weight: float,
                                           month: int) -> Dict[str, float]:
        """
        æ ¹æ®ç­–ç•¥è®¡ç®—æ¯ä¸ªå®¶åº­çš„åˆ†é…é‡‘é¢
        
        Args:
            all_workers: æ‰€æœ‰æœ‰åŠ³åŠ¨åŠ›çš„å®¶åº­IDåˆ—è¡¨
            total_tax: ç¨æ”¶æ€»é¢
            strategy: åˆ†é…ç­–ç•¥
            poverty_weight: è´«å›°æƒé‡
            unemployment_weight: å¤±ä¸šæƒé‡
            family_size_weight: å®¶åº­è§„æ¨¡æƒé‡
            month: å½“å‰æœˆä»½
            
        Returns:
            Dict[str, float]: å®¶åº­IDåˆ°åˆ†é…é‡‘é¢çš„æ˜ å°„
        """
        if strategy == "equal":
            return self._equal_allocation(all_workers, total_tax)
        elif strategy == "income_proportional":
            return self._income_proportional_allocation(all_workers, total_tax, month)
        elif strategy == "poverty_focused":
            return self._poverty_focused_allocation(all_workers, total_tax, month)
        elif strategy == "unemployment_focused":
            return self._unemployment_focused_allocation(all_workers, total_tax, month)
        elif strategy == "family_size":
            return self._family_size_allocation(all_workers, total_tax)
        elif strategy == "mixed":
            return self._mixed_allocation(all_workers, total_tax, poverty_weight,
                                        unemployment_weight, family_size_weight, month)
        else:
            print(f"Unknown redistribution strategy: {strategy}, using equal allocation")
            return self._equal_allocation(all_workers, total_tax)

    def _equal_allocation(self, all_workers: List[str], total_tax: float) -> Dict[str, float]:
        """å¹³å‡åˆ†é…ç­–ç•¥"""
        amount_per_household = total_tax / len(all_workers)
        return {household_id: amount_per_household for household_id in all_workers}

    def _income_proportional_allocation(self, all_workers: List[str], total_tax: float, month: int) -> Dict[str, float]:
        """æŒ‰æ”¶å…¥æ¯”ä¾‹åˆ†é…ç­–ç•¥"""
        household_incomes = {}
        total_income = 0.0
        
        for household_id in all_workers:
            monthly_income, _, _ = self.compute_household_monthly_stats(household_id, month)
            household_incomes[household_id] = monthly_income
            total_income += monthly_income
        
        if total_income <= 0:
            return self._equal_allocation(all_workers, total_tax)
        
        allocations = {}
        for household_id in all_workers:
            proportion = household_incomes[household_id] / total_income
            allocations[household_id] = total_tax * proportion
        
        return allocations

    def _poverty_focused_allocation(self, all_workers: List[str], total_tax: float, month: int) -> Dict[str, float]:
        """è´«å›°å¯¼å‘åˆ†é…ç­–ç•¥ï¼ˆæ”¶å…¥è¶Šä½åˆ†é…è¶Šå¤šï¼‰"""
        household_incomes = {}
        household_balances = {}
        
        for household_id in all_workers:
            monthly_income, _, balance = self.compute_household_monthly_stats(household_id, month)
            household_incomes[household_id] = monthly_income
            household_balances[household_id] = balance
        
        if not household_incomes:
            return self._equal_allocation(all_workers, total_tax)
        
        max_income = max(household_incomes.values())
        min_income = min(household_incomes.values())
        max_balance = max(household_balances.values()) if household_balances else 0.0
        min_balance = min(household_balances.values()) if household_balances else 0.0
        
        # è‹¥æ”¶å…¥ä¸å­˜æ¬¾éƒ½æ— å·®å¼‚ï¼Œåˆ™é€€åŒ–ä¸ºå‡åˆ†
        if max_income == min_income and max_balance == min_balance:
            return self._equal_allocation(all_workers, total_tax)
        
        # è®¡ç®—è´«å›°æƒé‡ï¼ˆæ”¶å…¥è¶Šä½ã€å­˜æ¬¾è¶Šä½æƒé‡è¶Šé«˜ï¼‰
        # ç»„åˆæƒé‡ï¼šalpha ç”¨äºæ§åˆ¶æ”¶å…¥ä¸å­˜æ¬¾çš„æƒé‡å æ¯”
        alpha = 0.5  # å¯æŒ‰éœ€è°ƒæ•´/æš´éœ²ä¸ºè¶…å‚æ•°
        poverty_weights = {}
        total_weight = 0.0
        
        for household_id, income in household_incomes.items():
            # æ”¶å…¥æˆåˆ†ï¼ˆè¶Šä½è¶Šé«˜ï¼‰
            income_component = 0.0
            if max_income != min_income:
                income_component = (max_income - income) / (max_income - min_income)
            
            # å­˜æ¬¾æˆåˆ†ï¼ˆè¶Šä½è¶Šé«˜ï¼‰
            balance = household_balances.get(household_id, 0.0)
            balance_component = 0.0
            if max_balance != min_balance:
                balance_component = (max_balance - balance) / (max_balance - min_balance)
            
            # ç»¼åˆæƒé‡
            weight = alpha * income_component + (1 - alpha) * balance_component
            poverty_weights[household_id] = weight
            total_weight += weight
        
        allocations = {}
        for household_id in all_workers:
            proportion = poverty_weights[household_id] / total_weight
            allocations[household_id] = total_tax * proportion
        
        return allocations

    def _unemployment_focused_allocation(self, all_workers: List[str], total_tax: float, month: int) -> Dict[str, float]:
        """å¤±ä¸šå¯¼å‘åˆ†é…ç­–ç•¥ï¼ˆå¤±ä¸šè€…è·å¾—æ›´å¤šï¼‰"""
        unemployment_weights = {}
        total_weight = 0.0
        
        for household_id in all_workers:
            labor_hours = self.laborhour.get(household_id, [])
            employed_count = sum(1 for lh in labor_hours if not lh.is_valid and lh.firm_id is not None)
            unemployed_count = len(labor_hours) - employed_count
            
            # å¤±ä¸šè€…æƒé‡æ›´é«˜
            weight = unemployed_count * 2.0 + employed_count * 1.0
            unemployment_weights[household_id] = weight
            total_weight += weight
        
        if total_weight <= 0:
            return self._equal_allocation(all_workers, total_tax)
        
        allocations = {}
        for household_id in all_workers:
            proportion = unemployment_weights[household_id] / total_weight
            allocations[household_id] = total_tax * proportion
        
        return allocations

    def _family_size_allocation(self, all_workers: List[str], total_tax: float) -> Dict[str, float]:
        """æŒ‰å®¶åº­è§„æ¨¡åˆ†é…ç­–ç•¥"""
        family_weights = {}
        total_weight = 0.0
        
        for household_id in all_workers:
            labor_hours = self.laborhour.get(household_id, [])
            family_size = len(labor_hours)
            family_weights[household_id] = family_size
            total_weight += family_size
        
        if total_weight <= 0:
            return self._equal_allocation(all_workers, total_tax)
        
        allocations = {}
        for household_id in all_workers:
            proportion = family_weights[household_id] / total_weight
            allocations[household_id] = total_tax * proportion
        
        return allocations

    def _mixed_allocation(self, all_workers: List[str], total_tax: float,
                         poverty_weight: float, unemployment_weight: float,
                         family_size_weight: float, month: int) -> Dict[str, float]:
        """æ··åˆåˆ†é…ç­–ç•¥"""
        # è·å–å„ç§æƒé‡
        poverty_allocations = self._poverty_focused_allocation(all_workers, total_tax, month)
        unemployment_allocations = self._unemployment_focused_allocation(all_workers, total_tax, month)
        family_size_allocations = self._family_size_allocation(all_workers, total_tax)
        equal_allocations = self._equal_allocation(all_workers, total_tax)
        
        # è®¡ç®—å‰©ä½™æƒé‡
        remaining_weight = 1.0 - poverty_weight - unemployment_weight - family_size_weight
        if remaining_weight < 0:
            remaining_weight = 0.0
        
        # æ··åˆåˆ†é…
        allocations = {}
        for household_id in all_workers:
            mixed_amount = (
                poverty_allocations[household_id] * poverty_weight +
                unemployment_allocations[household_id] * unemployment_weight +
                family_size_allocations[household_id] * family_size_weight +
                equal_allocations[household_id] * remaining_weight
            )
            allocations[household_id] = mixed_amount
        
        return allocations


    # =========================================================================
    # Transaction Creation Methods
    # =========================================================================
    def add_interest_tx(self, month: int, sender_id: str, receiver_id: str, amount: float) -> str:
        """
        æ·»åŠ åˆ©æ¯äº¤æ˜“è®°å½•
        """
        tx = self._record_transaction(
            sender_id=sender_id,
            receiver_id=receiver_id,
            amount=amount,
            tx_type='interest',
            month=month,
        )
        return tx.id
    def add_redistribution_tx(self, month: int, sender_id: str, receiver_id: str, amount: float) -> str:
        """
        æ·»åŠ å†åˆ†é…äº¤æ˜“è®°å½•
        """
        tx = self._record_transaction(
            sender_id=sender_id,
            receiver_id=receiver_id,
            amount=amount,
            tx_type='redistribution',
            month=month,
        )
        return tx.id

    def add_tx_service(self, month: int, sender_id: str, receiver_id: str, amount: float) -> str:
        """
        æ·»åŠ æœåŠ¡ç±»å‹äº¤æ˜“è®°å½•ï¼Œç›´æ¥æ›´æ–°è´¦æœ¬å¹¶è®°å½•åˆ°äº¤æ˜“å†å²
        ç”¨äºæ”¿åºœæœåŠ¡ã€åŸºç¡€æœåŠ¡ç­‰ä¸éœ€è¦å•†å“åº“å­˜çš„äº¤æ˜“
        
        Args:
            month: äº¤æ˜“æœˆä»½
            sender_id: ä»˜æ¬¾æ–¹ID
            receiver_id: æ”¶æ¬¾æ–¹ID
            amount: äº¤æ˜“é‡‘é¢
            
        Returns:
            str: äº¤æ˜“ID
        """
        # ğŸ”§ ä¿®æ”¹ï¼šåªæ£€æŸ¥å®¶åº­çš„ä½™é¢ï¼Œä¼ä¸šå…è®¸è´Ÿå€º
        # åˆ¤æ–­æ˜¯å¦æ˜¯ä¼ä¸šï¼šfirm_id åœ¨ self.firm_id åˆ—è¡¨ä¸­
        is_company = sender_id in self.firm_id
        
        if not is_company and self.ledger[sender_id].amount < amount:
            # å®¶åº­ä½™é¢ä¸è¶³ï¼Œä¸å…è®¸äº¤æ˜“
            raise ValueError(f"Insufficient balance for household {sender_id}: ${self.ledger[sender_id].amount:.2f} < ${amount:.2f}")
        elif is_company and self.ledger[sender_id].amount < amount:
            # ä¼ä¸šä½™é¢ä¸è¶³ï¼Œå…è®¸è´Ÿå€ºäº¤æ˜“ï¼Œè®°å½•æ—¥å¿—
            self.logger.info(f"ğŸ’³ Company {sender_id} transaction with negative balance: "
                      f"${self.ledger[sender_id].amount:.2f} â†’ ${self.ledger[sender_id].amount - amount:.2f}")
        
        # ç›´æ¥æ›´æ–°è´¦æœ¬
        self.ledger[sender_id].amount -= amount
        self.ledger[receiver_id].amount += amount
        
        # åˆ›å»ºæœåŠ¡äº¤æ˜“è®°å½•
        tx = self._record_transaction(
            sender_id=sender_id,
            receiver_id=receiver_id,
            amount=amount,
            assets=[],  # æœåŠ¡äº¤æ˜“æ²¡æœ‰å…·ä½“å•†å“
            tx_type='service',  # ä½¿ç”¨serviceç±»å‹
            month=month,
        )
       
        return tx.id
    
    def add_inherent_market_transaction(
        self,
        month: int,
        sender_id: str,
        receiver_id: str,
        amount: float,
        product_id: str,
        quantity: float,
        product_name: str = "Unknown",
        product_price: float = 0.0,
        product_classification: str = "Unknown",
        consume_inventory: bool = False,
    ) -> str:
        """
        æ·»åŠ å›ºæœ‰å¸‚åœºäº¤æ˜“è®°å½•ï¼ˆåŒ…å«æ¯›åˆ©ç‡è®¡ç®—ï¼‰
        ç”¨äºè®°å½•æ”¿åºœé€šè¿‡å›ºæœ‰å¸‚åœºè´­ä¹°ä¼ä¸šå•†å“çš„äº¤æ˜“
        
        Args:
            month: äº¤æ˜“æœˆä»½
            sender_id: ä»˜æ¬¾æ–¹ID (é€šå¸¸æ˜¯æ”¿åºœ)
            receiver_id: æ”¶æ¬¾æ–¹ID (ä¼ä¸š)
            amount: äº¤æ˜“é‡‘é¢
            product_id: å•†å“ID
            quantity: è´­ä¹°æ•°é‡
            product_name: å•†å“åç§°
            product_price: å•†å“å•ä»·
            product_classification: å•†å“åˆ†ç±»ï¼ˆdaily_cateï¼‰
            
        Returns:
            str: äº¤æ˜“ID
        """
        # ğŸ”§ ä¿®æ”¹ï¼šåªæ£€æŸ¥å®¶åº­å’Œæ”¿åºœçš„ä½™é¢ï¼Œä¼ä¸šå…è®¸è´Ÿå€º
        is_company = sender_id in self.firm_id
        
        if not is_company and self.ledger[sender_id].amount < amount:
            # å®¶åº­/æ”¿åºœä½™é¢ä¸è¶³ï¼Œä¸å…è®¸äº¤æ˜“
            raise ValueError(f"Insufficient balance for {sender_id}: ${self.ledger[sender_id].amount:.2f} < ${amount:.2f}")
        elif is_company and self.ledger[sender_id].amount < amount:
            # ä¼ä¸šä½™é¢ä¸è¶³ï¼Œå…è®¸è´Ÿå€ºäº¤æ˜“
            self.logger.info(f"ğŸ’³ Company {sender_id} inherent market transaction with negative balance: "
                      f"${self.ledger[sender_id].amount:.2f} â†’ ${self.ledger[sender_id].amount - amount:.2f}")

        # ğŸ”’ æ³¨æ„ï¼šå›ºæœ‰å¸‚åœºå¯é€‰æ‹©åœ¨æ­¤å¤„åŸå­æ‰£åº“å­˜ï¼ˆconsume_inventory=Trueï¼‰ï¼Œé¿å…â€œå…ˆæ‰£åº“å­˜åè®°è´¦â€å¤±è´¥å¯¼è‡´ä¸ä¸€è‡´ã€‚
        # éªŒè¯å•†å“æ˜¯å¦å­˜åœ¨å¹¶è®°å½•å½“å‰åº“å­˜çŠ¶æ€
        product_found = False
        current_inventory = 0.0
        if receiver_id in self.products:
            for product in self.products[receiver_id]:
                if product.product_id == product_id:
                    product_found = True
                    current_inventory = product.amount
                    if consume_inventory:
                        eps = 1e-9
                        if current_inventory + eps < quantity:
                            raise ValueError(
                                f"Insufficient inventory for {receiver_id}:{product_id}: "
                                f"{current_inventory} < {quantity}"
                            )
                        product.amount = max(0.0, float(product.amount) - float(quantity))
                        current_inventory = product.amount
                        self.logger.info(
                            f"å›ºæœ‰å¸‚åœºè´­ä¹°: ä¼ä¸š {receiver_id} å•†å“ {product_name} æ¶ˆè€— {quantity}ä»¶ï¼Œå‰©ä½™ {current_inventory}ä»¶"
                        )
                    else:
                        # æ—§è¡Œä¸ºï¼šåº“å­˜å·²åœ¨è°ƒç”¨æ–¹æ‰£å‡ï¼Œè¿™é‡Œä»…è®°å½•æ‰£å‡åçš„åº“å­˜
                        self.logger.info(
                            f"å›ºæœ‰å¸‚åœºè´­ä¹°: ä¼ä¸š {receiver_id} å•†å“ {product_name} å·²æ¶ˆè€— {quantity}ä»¶ï¼Œå‰©ä½™ {current_inventory}ä»¶"
                        )
                    break

        if not product_found:
            self.logger.warning(f"å›ºæœ‰å¸‚åœºè´­ä¹°: æœªæ‰¾åˆ°ä¼ä¸š {receiver_id} çš„å•†å“ {product_id}")
            if consume_inventory:
                raise ValueError(f"Product not found for inherent market: {receiver_id}:{product_id}")

        # æ”¿åºœ/ä¹°æ–¹æ”¯ä»˜ä¼ä¸šï¼ˆä¸å«ç¨é”€å”®é¢ï¼‰
        self.ledger[sender_id].amount -= amount
        self.ledger[receiver_id].amount += amount

        # ğŸ§¾ å›ºæœ‰å¸‚åœºåŒæ ·è®¡å…¥ VATï¼ˆæ¶ˆè´¹ç¨ï¼‰
        # é€»è¾‘ä¸å®¶åº­è´­ä¹°ä¸€è‡´ï¼šç¨åŸºä¸ºä¸å«ç¨é”€å”®é¢ amountï¼Œç¨é¢=amount*vat_rateã€‚
        # è‹¥ sender æœ¬èº«å°±æ˜¯æ”¿åºœï¼ˆgov_main_simulationï¼‰ï¼Œè¯¥ç¨æ¬¾åœ¨è´¦é¢ä¸Šâ€œè½¬ç»™è‡ªå·±â€ä¸ä¼šæ”¹å˜ä½™é¢ï¼Œ
        # ä½†ä»ä¼šç”Ÿæˆ consume_tax äº¤æ˜“è®°å½•ï¼Œä¾›ç»Ÿè®¡ä¸GDPæ ¸ç®—ä½¿ç”¨ã€‚
        tax_amount = float(amount or 0.0) * float(self.vat_rate or 0.0)
        if tax_amount > 0:
            gov_id = "gov_main_simulation"
            # ç¡®ä¿æ”¿åºœè´¦æœ¬å­˜åœ¨
            if gov_id in self.ledger:
                self.ledger[sender_id].amount -= tax_amount
                self.ledger[gov_id].amount += tax_amount
            tax_tx = self._record_transaction(
                sender_id=sender_id,
                receiver_id=gov_id,
                amount=tax_amount,
                tx_type='consume_tax',
                month=month,
                metadata={
                    "tax_base": amount,
                    "tax_rate": self.vat_rate,
                    "product_id": product_id,
                    "quantity": float(quantity or 0.0),
                },
            )
        
        # ğŸ’° ä¼ä¸šæ”¶å…¥ï¼ˆç°é‡‘æµå£å¾„ï¼‰ï¼šåªè®°å½•çœŸå®æ”¶æ¬¾é¢ï¼›ç”Ÿäº§æˆæœ¬åœ¨ç”Ÿäº§é˜¶æ®µè®°æ”¯å‡º
        revenue = amount
        self.record_firm_income(receiver_id, revenue)
        self.record_firm_monthly_income(receiver_id, month, revenue)
        
        # åˆ›å»ºå›ºæœ‰å¸‚åœºäº¤æ˜“è®°å½•
        unit_price = product_price if product_price > 0 else (amount / quantity if quantity > 0 else 0)
        if unit_price <= 0:
            unit_price = 0.01
            
        product_kwargs = dict(
            asset_type='products',
            product_id=product_id,
            name=product_name,
            owner_id=receiver_id,
            amount=quantity,
            price=unit_price,
            classification=product_classification
        )
        product_kwargs = inject_product_attributes(product_kwargs, product_id)
        product_asset = Product(**product_kwargs)
        
        tx = self._record_transaction(
            sender_id=sender_id,
            receiver_id=receiver_id,
            amount=amount,
            assets=[product_asset],
            tx_type='inherent_market',
            month=month,
            metadata={
                "product_id": product_id,
                "product_name": product_name,
                "quantity": float(quantity or 0.0),
                "unit_price": float(unit_price or 0.0),
                "product_classification": product_classification,
                "consume_inventory": consume_inventory,
            },
        )
        
        # ä¼ä¸šæ‰€å¾—ç¨æ”¹ä¸ºâ€œæœˆåº¦ç»“ç®—â€ï¼ˆæŒ‰å‡€åˆ©æ¶¦è®¡ç¨ï¼‰ï¼Œé¿å…ä¸ç”Ÿäº§é¢„ç®—å½¢æˆå¾ªç¯ä¾èµ–ã€‚
        
        # self.logger.info(f"å›ºæœ‰å¸‚åœºäº¤æ˜“: æ”¿åºœè´­ä¹°å•†å“ {product_name}(ID:{product_id}, {product_classification}) "
        #            f"æ•°é‡ {quantity} é‡‘é¢ ${amount:.2f}, æˆæœ¬ ${cost:.2f}, æ¯›åˆ©æ¶¦ ${gross_profit:.2f} (æ¯›åˆ©ç‡{profit_margin}%), "
        #            f"ä¼ä¸šæ‰€å¾—ç¨ ${corporate_tax:.2f}")
        
        return tx.id

    def add_government_procurement_transaction(
        self,
        month: int,
        sender_id: str,
        receiver_id: str,
        amount: float,
        product_id: str,
        quantity: float,
        product_name: str = "Unknown",
        unit_price: float = 0.0,
        product_classification: str = "Unknown",
        consume_inventory: bool = True,
    ) -> str:
        """
        Government procurement transaction:
        - No VAT/consume_tax is generated (avoid government self-tax artifacts).
        - Books firm revenue (cashflow) equal to `amount` (ex-tax).
        - Optionally consumes inventory atomically.
        """
        # Balance check (government is not a company)
        is_company = sender_id in self.firm_id
        if not is_company and self.ledger[sender_id].amount < amount:
            raise ValueError(f"Insufficient balance for {sender_id}: ${self.ledger[sender_id].amount:.2f} < ${amount:.2f}")

        # Inventory consume
        if consume_inventory:
            product_found = False
            current_inventory = 0.0
            if receiver_id in self.products:
                for p in (self.products.get(receiver_id) or []):
                    if str(getattr(p, "product_id", "") or "") == str(product_id):
                        product_found = True
                        current_inventory = float(getattr(p, "amount", 0.0) or 0.0)
                        eps = 1e-9
                        if current_inventory + eps < float(quantity or 0.0):
                            raise ValueError(
                                f"Insufficient inventory for {receiver_id}:{product_id}: "
                                f"{current_inventory} < {quantity}"
                            )
                        p.amount = max(0.0, float(p.amount) - float(quantity))
                        current_inventory = float(p.amount)
                        # enrich fields from inventory product
                        try:
                            self._ensure_product_cost_fields(p, default_category=getattr(p, "classification", product_classification))
                            product_name = str(getattr(p, "name", product_name) or product_name)
                            product_classification = getattr(p, "classification", product_classification) or product_classification
                            if unit_price <= 0:
                                unit_price = float(getattr(p, "price", 0.0) or 0.0)
                        except Exception:
                            pass
                        break
            if not product_found:
                raise ValueError(f"Product not found for government procurement: {receiver_id}:{product_id}")

        # Ledger transfer
        self.ledger[sender_id].amount -= amount
        self.ledger[receiver_id].amount += amount

        # Firm revenue bookkeeping (cashflow)
        self.record_firm_income(receiver_id, amount)
        self.record_firm_monthly_income(receiver_id, month, amount)

        # Transaction asset payload (quantity = purchased quantity)
        if unit_price <= 0 and quantity and float(quantity) > 0:
            unit_price = float(amount) / float(quantity)
        if unit_price <= 0:
            unit_price = 0.01

        product_kwargs = dict(
            asset_type="products",
            product_id=str(product_id),
            name=str(product_name),
            owner_id=str(receiver_id),
            amount=float(quantity or 0.0),
            price=float(unit_price),
            classification=str(product_classification or "Unknown"),
        )
        product_kwargs = inject_product_attributes(product_kwargs, str(product_id))
        product_asset = Product(**product_kwargs)

        tx = self._record_transaction(
            sender_id=sender_id,
            receiver_id=receiver_id,
            amount=float(amount or 0.0),
            assets=[product_asset],
            tx_type="government_procurement",
            month=month,
            metadata={
                "product_id": product_id,
                "product_name": product_name,
                "quantity": float(quantity or 0.0),
                "unit_price": float(unit_price or 0.0),
                "product_classification": product_classification,
                "consume_inventory": consume_inventory,
            },
        )
        return tx.id
    

    # =========================================================================
    # Inventory & Pricing Management
    # =========================================================================
    def get_product_inventory(self, owner_id: str, product_id: str) -> float:
        """
        è·å–æŒ‡å®šå•†å“çš„å½“å‰åº“å­˜æ•°é‡
        """
        if owner_id not in self.products:
            return 0.0
        
        for product in self.products[owner_id]:
            if product.product_id == product_id:
                return product.amount
        return 0.0
    
    def get_all_product_inventory(self) -> Dict[tuple, float]:
        """
        æ‰¹é‡è·å–æ‰€æœ‰å•†å“çš„åº“å­˜ä¿¡æ¯
        
        Returns:
            Dict[tuple, float]: {(product_id, owner_id): amount} å­—å…¸
        """
        inventory_dict = {}
        for owner_id, products in self.products.items():
            for product in products:
                key = (product.product_id, owner_id)
                inventory_dict[key] = product.amount
        return inventory_dict
    
    async def sync_product_inventory_to_market(self, product_market):
        """
        å°†EconomicCenterçš„åº“å­˜ä¿¡æ¯åŒæ­¥åˆ°ProductMarket
        è¿™ä¸ªæ–¹æ³•å¯ä»¥å®šæœŸè°ƒç”¨ä»¥ä¿æŒä¸¤è¾¹æ•°æ®ä¸€è‡´
        """
        try:
            # æ”¶é›†æ‰€æœ‰æœ‰åº“å­˜çš„å•†å“
            all_products = []
            for owner_id, products in self.products.items():
                if owner_id in self.firm_id:
                    for product in products:
                        if product.amount > 0:  # åªåŒæ­¥æœ‰åº“å­˜çš„å•†å“
                            all_products.append(product)
            
            # æ›´æ–°ProductMarketçš„å•†å“åˆ—è¡¨
            await product_market.update_products_from_economic_center.remote(all_products)
            self.logger.info(f"å·²åŒæ­¥ {len(all_products)} ä¸ªå•†å“åˆ°ProductMarket")
            return True
        except Exception as e:
            self.logger.error(f"åŒæ­¥åº“å­˜åˆ°ProductMarketå¤±è´¥: {e}")
            return False
    
    def update_product_prices_based_on_sales(
        self,
        sales_data: Dict[tuple, Dict],
        price_adjustment_rate: float = 0.1,
        unmet_demand_lambda: float = 1.0,
    ) -> Dict[str, float]:
        """
        æ ¹æ®é”€é‡æ•°æ®æ›´æ–°å•†å“ä»·æ ¼ï¼ˆåŒ…å«åº“å­˜ä¿¡æ¯ï¼‰
        sales_data: {(product_id, seller_id): {"quantity_sold": float, "revenue": float, "demand_level": str}}
        price_adjustment_rate: ä»·æ ¼è°ƒæ•´å¹…åº¦ (0.1 = 10%)
        è¿”å›: {product_id: new_price}
        
        æ³¨æ„ï¼šä½¿ç”¨ (product_id, seller_id) ä½œä¸ºkeyï¼Œæ”¯æŒç«äº‰å¸‚åœºæ¨¡å¼ä¸‹åŒä¸€å•†å“ç”±å¤šä¸ªä¼ä¸šé”€å”®
        """
        price_changes = {}
        
        # ğŸ” è°ƒè¯•ä¿¡æ¯ï¼šæ£€æŸ¥ firm_id åˆ—è¡¨
        self.logger.info(f"ğŸ“‹ å·²æ³¨å†Œçš„ä¼ä¸šæ•°é‡: {len(self.firm_id)}")
        self.logger.info(f"ğŸ“¦ å•†å“æ‰€æœ‰è€…æ•°é‡: {len(self.products)}")
        
        processed_owners = 0
        skipped_owners = 0
        price_increase_count = 0
        price_decrease_count = 0
        
        for owner_id, products in self.products.items():
            if owner_id in self.firm_id:  # åªå¤„ç†çœŸæ­£çš„å…¬å¸
                processed_owners += 1
                for product in products:
                    product_id = product.product_id
                    sales_key = (product_id, owner_id)
                    
                    # ä½¿ç”¨ (product_id, owner_id) ä½œä¸ºkeyæŸ¥æ‰¾é”€é‡æ•°æ®
                    if sales_key in sales_data:
                        sales_info = sales_data[sales_key]
                        # âš ï¸ å›ºæœ‰å¸‚åœºè‹¥â€œå‡ºæ¸…åº“å­˜â€ï¼Œä¼šè®© quantity_sold å˜æˆâ€œäº§é‡â€ï¼Œä»è€Œè¯¯åˆ¤â€œå…¨éƒ¨ä¾›ä¸åº”æ±‚â€ã€‚
                        # ä¿®æ­£ï¼š
                        # - éœ€æ±‚ä¾§ï¼šä»¥å®¶åº­éœ€æ±‚ä¸ºä¸»ï¼Œå¹¶åŠ ä¸Šæœªæ»¡è¶³éœ€æ±‚ï¼ˆç¼ºè´§ï¼‰åŠ æƒ
                        # - ä¾›ç»™ä¾§ï¼šæŠŠå›ºæœ‰å¸‚åœºè´­ä¹°é‡è§†ä½œâ€œæœˆæœ«å‰©ä½™/è¿‡å‰©ä¾›ç»™â€ä¿¡å·ï¼ˆè¿‘ä¼¼ï¼‰
                        household_qty = float(sales_info.get("household_quantity", 0.0) or 0.0)
                        household_revenue = float(sales_info.get("household_revenue", 0.0) or 0.0)
                        inherent_qty = float(sales_info.get("inherent_market_quantity", 0.0) or 0.0)
                        gov_qty = float(sales_info.get("government_procurement_quantity", 0.0) or 0.0)
                        unmet_short = float(sales_info.get("unmet_qty_short", 0.0) or 0.0)

                        try:
                            lam = float(unmet_demand_lambda or 0.0)
                        except Exception:
                            lam = 0.0
                        lam = max(0.0, min(10.0, lam))

                        quantity_sold = household_qty + lam * unmet_short
                        revenue = household_revenue
                        demand_level = sales_info.get("demand_level", "normal")
                        # ä»·æ ¼è°ƒèŠ‚å¸Œæœ›çœ‹åˆ°â€œæœˆå†…å¯ä¾›ç»™è§„æ¨¡â€ï¼Œè€Œä¸æ˜¯â€œå‡ºæ¸…åå‰©ä½™åº“å­˜â€ï¼š
                        # - inherent_market ä¸ government_procurement éƒ½å¯èƒ½æŠŠåº“å­˜æ¸…åˆ°0ï¼ˆç±»ä¼¼å‡ºæ¸…é€šé“ï¼‰
                        # - è¿™é‡ŒæŠŠå®ƒä»¬çš„è´­ä¹°æ•°é‡åŠ å›å»ï¼Œè¿‘ä¼¼æ¢å¤åˆ°â€œå‡ºæ¸…å‰åº“å­˜æ°´å¹³â€
                        current_inventory = float(getattr(product, "amount", 0.0) or 0.0) + inherent_qty + gov_qty
                        
                        # è®¡ç®—ä»·æ ¼è°ƒæ•´ï¼ˆä¼ å…¥åº“å­˜ä¿¡æ¯ï¼‰
                        old_price = product.price
                        new_price = self._calculate_new_price(
                            old_price, quantity_sold, revenue, demand_level,
                            price_adjustment_rate, current_inventory
                        )
                        
                        # æ›´æ–°ä»·æ ¼
                        product.price = new_price
                        price_changes[product_id] = new_price
                        
                        # ç»Ÿè®¡æ¶¨ä»·å’Œé™ä»·å•†å“æ•°
                        if new_price > old_price:
                            price_increase_count += 1
                        elif new_price < old_price:
                            price_decrease_count += 1
                        
                        # æ‰“å°ä»·æ ¼å˜åŒ–
                        price_change_pct = ((new_price - old_price) / old_price * 100) if old_price > 0 else 0
                        supply_demand_ratio = current_inventory / quantity_sold if quantity_sold > 0 else float('inf')
                        
                        if abs(price_change_pct) > 5:  # åªæ‰“å°å˜åŒ–è¶…è¿‡5%çš„
                            print(f"ğŸ’¹ {product.name[:40]:40} | "
                                  f"${old_price:6.2f} â†’ ${new_price:6.2f} ({price_change_pct:+6.1f}%) | "
                                  f"é”€é‡:{quantity_sold:5.1f} | åº“å­˜:{current_inventory:5.1f} | "
                                  f"ä¾›éœ€æ¯”:{supply_demand_ratio:5.2f} | {demand_level}")
            else:
                skipped_owners += 1
        
        self.logger.info(f"âœ… å¤„ç†äº† {processed_owners} ä¸ªä¼ä¸šçš„å•†å“ï¼Œè·³è¿‡äº† {skipped_owners} ä¸ªéä¼ä¸šæ‰€æœ‰è€…")
        print(f"\nğŸ“Š ä»·æ ¼è°ƒæ•´æ±‡æ€»: æ¶¨ä»· {price_increase_count} ç§å•†å“, é™ä»· {price_decrease_count} ç§å•†å“")
        
        if skipped_owners > 0:
            self.logger.warning(f"âš ï¸ è·³è¿‡çš„æ‰€æœ‰è€…ç¤ºä¾‹: {list(self.products.keys())[:5]}")
            self.logger.warning(f"âš ï¸ å·²æ³¨å†Œä¼ä¸šIDç¤ºä¾‹: {self.firm_id[:5] if self.firm_id else 'ç©ºåˆ—è¡¨'}")
        
        return price_changes
    
    def _calculate_new_price(self, current_price: float, quantity_sold: float, revenue: float,
                           demand_level: str, adjustment_rate: float, current_inventory: float = None) -> float:
        """
        âœ¨ ä¼˜åŒ–ç‰ˆä»·æ ¼è°ƒæ•´ç®—æ³• - è®©ä¾›ä¸åº”æ±‚çš„å•†å“æ›´æ˜æ˜¾æ¶¨ä»·
        
        è€ƒè™‘å› ç´ ï¼š
        1. é”€é‡æ°´å¹³ï¼ˆç»å¯¹å€¼ï¼‰
        2. éœ€æ±‚æ°´å¹³ï¼ˆhigh/normal/lowï¼‰
        3. ä¾›éœ€æ¯”ï¼ˆåº“å­˜ä¸é”€é‡çš„æ¯”ä¾‹ï¼‰- æ–°å¢
        4. æ”¶å…¥æ•ˆç‡
        """
        # åŸºç¡€ä»·æ ¼è°ƒæ•´å› å­
        base_adjustment = 0.0
        
        # 1. æ ¹æ®é”€é‡è°ƒæ•´ï¼ˆæ›´æ¿€è¿›çš„è°ƒæ•´ï¼‰
        if quantity_sold > 100:  # è¶…é«˜é”€é‡
            base_adjustment += 0.15  # æ¶¨ä»·15%
        elif quantity_sold > 50:  # é«˜é”€é‡
            base_adjustment += 0.10  # æ¶¨ä»·10%
        elif quantity_sold > 30:  # ä¸­ç­‰é”€é‡
            base_adjustment += 0.05  # æ¶¨ä»·5%
        elif quantity_sold < 5:  # æä½é”€é‡
            base_adjustment -= 0.08  # é™ä»·8%
        elif quantity_sold < 15:  # ä½é”€é‡
            base_adjustment -= 0.05  # é™ä»·5%
        
        # 2. æ ¹æ®éœ€æ±‚æ°´å¹³è°ƒæ•´ï¼ˆæ›´æ¿€è¿›ï¼‰
        demand_multipliers = {
            "high": 0.20,      # é«˜éœ€æ±‚æ¶¨ä»·20%
            "normal": 0.0,     # æ­£å¸¸éœ€æ±‚ä¸å˜
            "low": -0.12       # ä½éœ€æ±‚é™ä»·12%
        }
        base_adjustment += demand_multipliers.get(demand_level, 0.0)
        
        # 3. âœ¨ æ–°å¢ï¼šæ ¹æ®ä¾›éœ€æ¯”è°ƒæ•´ï¼ˆåº“å­˜ä¸é”€é‡çš„æ¯”ä¾‹ï¼‰
        # è¿™æ˜¯å…³é”®çš„ä¾›ä¸åº”æ±‚åˆ¤æ–­æŒ‡æ ‡
        if current_inventory is not None and quantity_sold > 0:
            supply_demand_ratio = current_inventory / quantity_sold
            
            if supply_demand_ratio < 0.5:
                # åº“å­˜ä¸è¶³é”€é‡çš„ä¸€åŠ - ä¸¥é‡ä¾›ä¸åº”æ±‚
                base_adjustment += 0.25  # å¤§å¹…æ¶¨ä»·25%
                self.logger.debug(f"ğŸ”¥ ä¸¥é‡ä¾›ä¸åº”æ±‚: åº“å­˜{current_inventory:.1f} / é”€é‡{quantity_sold:.1f} = {supply_demand_ratio:.2f}")
            elif supply_demand_ratio < 1.0:
                # åº“å­˜ä¸è¶³ä¸€ä¸ªå‘¨æœŸçš„é”€é‡ - ä¾›ä¸åº”æ±‚
                base_adjustment += 0.15  # æ¶¨ä»·15%
                self.logger.debug(f"ğŸ“ˆ ä¾›ä¸åº”æ±‚: åº“å­˜{current_inventory:.1f} / é”€é‡{quantity_sold:.1f} = {supply_demand_ratio:.2f}")
            elif supply_demand_ratio < 2.0:
                # åº“å­˜ç•¥é«˜äºé”€é‡ - ä¾›éœ€å¹³è¡¡
                base_adjustment += 0.02  # å°å¹…æ¶¨ä»·2%
            elif supply_demand_ratio < 5.0:
                # åº“å­˜æ˜æ˜¾é«˜äºé”€é‡ - ä¾›è¿‡äºæ±‚
                base_adjustment -= 0.08  # é™ä»·8%
                self.logger.debug(f"ğŸ“‰ ä¾›è¿‡äºæ±‚: åº“å­˜{current_inventory:.1f} / é”€é‡{quantity_sold:.1f} = {supply_demand_ratio:.2f}")
            else:
                # åº“å­˜ä¸¥é‡è¿‡å‰© - ä¸¥é‡ä¾›è¿‡äºæ±‚
                base_adjustment -= 0.15  # å¤§å¹…é™ä»·15%
                self.logger.debug(f"âš ï¸ ä¸¥é‡ä¾›è¿‡äºæ±‚: åº“å­˜{current_inventory:.1f} / é”€é‡{quantity_sold:.1f} = {supply_demand_ratio:.2f}")
        
        # 4. æ ¹æ®æ”¶å…¥æ•ˆç‡è°ƒæ•´
        if revenue > 0 and quantity_sold > 0:
            avg_revenue_per_unit = revenue / quantity_sold
            if avg_revenue_per_unit > current_price * 1.15:  # æ”¶å…¥æ•ˆç‡é«˜ï¼ˆæé«˜é˜ˆå€¼ï¼‰
                base_adjustment += 0.05
            elif avg_revenue_per_unit < current_price * 0.85:  # æ”¶å…¥æ•ˆç‡ä½ï¼ˆé™ä½é˜ˆå€¼ï¼‰
                base_adjustment -= 0.05
        
        # 5. åº”ç”¨è°ƒæ•´ç‡ï¼ˆå¢å¤§è°ƒæ•´å¹…åº¦ï¼Œè®©ä»·æ ¼å˜åŒ–æ›´æ˜æ˜¾ï¼‰
        # åŸæ¥æ˜¯ç›´æ¥ä¹˜ä»¥adjustment_rateï¼Œç°åœ¨å¢åŠ ç³»æ•°è®©å˜åŒ–æ›´æ˜æ˜¾
        price_change = current_price * base_adjustment * adjustment_rate * 1.5  # æ”¾å¤§1.5å€
        
        # 6. è®¡ç®—æ–°ä»·æ ¼ï¼Œæ”¾å®½ä»·æ ¼å˜åŠ¨èŒƒå›´
        new_price = current_price + price_change
        min_price = current_price * 0.3   # æœ€ä½å¯é™è‡³åŸä»·çš„30%ï¼ˆåŸæ¥æ˜¯50%ï¼‰
        max_price = current_price * 3.0   # æœ€é«˜å¯æ¶¨è‡³åŸä»·çš„300%ï¼ˆåŸæ¥æ˜¯200%ï¼‰
        
        # 7. ç¡®ä¿ä»·æ ¼åˆç†æ€§ï¼ˆä¸èƒ½ä½äºæˆæœ¬çš„80%ï¼‰
        absolute_min_price = current_price * 0.4  # ç»å¯¹æœ€ä½ä»·
        
        final_price = max(absolute_min_price, min(new_price, max_price))
        
        # è®°å½•æ˜¾è‘—çš„ä»·æ ¼å˜åŒ–
        if abs(final_price - current_price) / current_price > 0.1:  # å˜åŒ–è¶…è¿‡10%
            inv_str = "N/A" if current_inventory is None else f"{float(current_inventory):.1f}"
            self.logger.info(f"ğŸ’¹ æ˜¾è‘—ä»·æ ¼å˜åŠ¨: ${current_price:.2f} â†’ ${final_price:.2f} "
                       f"({((final_price - current_price) / current_price * 100):+.1f}%) | "
                       f"é”€é‡:{quantity_sold:.1f} | åº“å­˜:{inv_str} | "
                       f"éœ€æ±‚:{demand_level}")
        
        return final_price
    
    async def sync_price_changes_to_market(self, product_market, price_changes: Dict[str, float]) -> bool:
        """
        å°†ä»·æ ¼å˜æ›´åŒæ­¥åˆ°ProductMarket
        """
        try:
            success = await product_market.update_product_prices.remote(price_changes)
            self.logger.info(f"å·²åŒæ­¥ {len(price_changes)} ä¸ªå•†å“çš„ä»·æ ¼å˜æ›´åˆ°ProductMarket")
            return success
        except Exception as e:
            self.logger.error(f"åŒæ­¥ä»·æ ¼å˜æ›´åˆ°ProductMarketå¤±è´¥: {e}")
            return False
    

    # =========================================================================
    # Sales Statistics & Market Analysis
    # =========================================================================
    def collect_sales_statistics(self, month: int) -> Dict[tuple, Dict]:
        """
        æ”¶é›†æŒ‡å®šæœˆä»½çš„é”€å”®ç»Ÿè®¡æ•°æ®
        è¿”å›: {(product_id, seller_id): {
            "product_id": str,
            "seller_id": str,
            "quantity_sold": float,
            "revenue": float,
            "demand_level": str,
            "household_quantity": float,  # å®¶åº­è´­ä¹°æ•°é‡
            "household_revenue": float,  # å®¶åº­è´­ä¹°æ”¶å…¥
            "inherent_market_quantity": float,  # å›ºå®šå¸‚åœºæ¶ˆè€—æ•°é‡
            "inherent_market_revenue": float,  # å›ºæœ‰å¸‚åœºæ”¶å…¥
            "government_procurement_quantity": float,  # æ”¿åºœé‡‡è´­æ•°é‡ï¼ˆä¸å«ç¨ï¼‰
            "government_procurement_revenue": float,  # æ”¿åºœé‡‡è´­æ”¶å…¥ï¼ˆä¸å«ç¨ï¼‰
        }}
        
        æ³¨æ„ï¼šä½¿ç”¨ (product_id, seller_id) ä½œä¸ºkeyï¼Œæ”¯æŒç«äº‰å¸‚åœºæ¨¡å¼ä¸‹åŒä¸€å•†å“ç”±å¤šä¸ªä¼ä¸šé”€å”®
        """
        sales_stats = {}
        
        # ä»äº¤æ˜“å†å²ä¸­æ”¶é›†é”€å”®æ•°æ®
        transactions = self.tx_by_month.get(month)
        if transactions is None:
            transactions = self.tx_history
        for tx in transactions:
            if tx.month == month:
                seller_id = tx.receiver_id
                
                # å¤„ç†å®¶åº­è´­ä¹°ï¼ˆpurchaseç±»å‹ï¼‰
                if tx.type == 'purchase':
                    for asset in tx.assets:
                        if hasattr(asset, 'product_id') and asset.product_id:
                            product_id = asset.product_id
                            key = (product_id, seller_id)
                            
                            if key not in sales_stats:
                                sales_stats[key] = {
                                    "product_id": product_id,
                                    "seller_id": seller_id,
                                    "quantity_sold": 0.0,
                                    "revenue": 0.0,
                                    "demand_level": "normal",
                                    "household_quantity": 0.0,
                                    "household_revenue": 0.0,  # æ–°å¢ï¼šå®¶åº­è´­ä¹°æ”¶å…¥
                                    "inherent_market_quantity": 0.0,
                                    "inherent_market_revenue": 0.0,  # æ–°å¢ï¼šå›ºæœ‰å¸‚åœºæ”¶å…¥
                                    "government_procurement_quantity": 0.0,
                                    "government_procurement_revenue": 0.0,
                                }
                            
                            # ç´¯è®¡å®¶åº­é”€é‡å’Œæ”¶å…¥
                            household_revenue = asset.price * asset.amount
                            sales_stats[key]["quantity_sold"] += asset.amount
                            sales_stats[key]["household_quantity"] += asset.amount
                            sales_stats[key]["revenue"] += household_revenue
                            sales_stats[key]["household_revenue"] += household_revenue

                
                # å¤„ç†å›ºå®šå¸‚åœºæ¶ˆè€—ï¼ˆinherent_marketç±»å‹ï¼‰
                elif tx.type == 'inherent_market':
                    for asset in tx.assets:
                        if hasattr(asset, 'product_id') and asset.product_id:
                            product_id = asset.product_id
                            key = (product_id, seller_id)
                            
                            if key not in sales_stats:
                                sales_stats[key] = {
                                    "product_id": product_id,
                                    "seller_id": seller_id,
                                    "quantity_sold": 0.0,
                                    "revenue": 0.0,
                                    "demand_level": "normal",
                                    "household_quantity": 0.0,
                                    "household_revenue": 0.0,  # æ–°å¢ï¼šå®¶åº­è´­ä¹°æ”¶å…¥
                                    "inherent_market_quantity": 0.0,
                                    "inherent_market_revenue": 0.0,  # æ–°å¢ï¼šå›ºæœ‰å¸‚åœºæ”¶å…¥
                                    "government_procurement_quantity": 0.0,
                                    "government_procurement_revenue": 0.0,
                                }
                            
                            # ç´¯è®¡å›ºå®šå¸‚åœºé”€é‡å’Œæ”¶å…¥
                            inherent_revenue = tx.amount  # å›ºå®šå¸‚åœºäº¤æ˜“çš„æ€»é‡‘é¢
                            sales_stats[key]["quantity_sold"] += asset.amount
                            sales_stats[key]["inherent_market_quantity"] += asset.amount
                            sales_stats[key]["revenue"] += inherent_revenue
                            sales_stats[key]["inherent_market_revenue"] += inherent_revenue

                # å¤„ç†æ”¿åºœé‡‡è´­ï¼ˆgovernment_procurementç±»å‹ï¼Œä¸å«ç¨ï¼‰
                elif tx.type == 'government_procurement':
                    for asset in tx.assets:
                        if hasattr(asset, 'product_id') and asset.product_id:
                            product_id = asset.product_id
                            key = (product_id, seller_id)

                            if key not in sales_stats:
                                sales_stats[key] = {
                                    "product_id": product_id,
                                    "seller_id": seller_id,
                                    "quantity_sold": 0.0,
                                    "revenue": 0.0,
                                    "demand_level": "normal",
                                    "household_quantity": 0.0,
                                    "household_revenue": 0.0,
                                    "inherent_market_quantity": 0.0,
                                    "inherent_market_revenue": 0.0,
                                    "government_procurement_quantity": 0.0,
                                    "government_procurement_revenue": 0.0,
                                }

                            gp_revenue = asset.price * asset.amount
                            sales_stats[key]["quantity_sold"] += asset.amount
                            sales_stats[key]["government_procurement_quantity"] += asset.amount
                            sales_stats[key]["revenue"] += gp_revenue
                            sales_stats[key]["government_procurement_revenue"] += gp_revenue
        
        # æ ¹æ®é”€é‡ç¡®å®šéœ€æ±‚æ°´å¹³
        # ===== Unmet Demand Tracking =====
        unmet_month = dict(self.unmet_demand_by_month.get(month, {}) or {})
        for key, stats in sales_stats.items():
            try:
                unmet_key = self._unmet_key(stats.get("product_id"), stats.get("seller_id"))
                rec = unmet_month.get(unmet_key, {}) if unmet_month else {}
                stats["unmet_attempts"] = float((rec or {}).get("attempts", 0.0) or 0.0)
                stats["unmet_qty_short"] = float((rec or {}).get("qty_short", 0.0) or 0.0)
            except Exception:
                stats["unmet_attempts"] = 0.0
                stats["unmet_qty_short"] = 0.0

            quantity = stats["quantity_sold"]
            if quantity > 100:
                stats["demand_level"] = "high"
            elif quantity < 10:
                stats["demand_level"] = "low"
            else:
                stats["demand_level"] = "normal"
        
        print(f"ğŸ“Š é”€å”®æ•°æ®æ”¶é›†: æœˆä»½{month}, äº¤æ˜“è®°å½•{len(self.tx_history)}æ¡, é”€å”®å•†å“-ä¼ä¸šç»„åˆ{len(sales_stats)}ç§")
        
        # è®¡ç®—æ€»æ”¶å…¥ç»Ÿè®¡
        total_revenue = sum(s['revenue'] for s in sales_stats.values())
        total_household_revenue = sum(s.get('household_revenue', 0) for s in sales_stats.values())
        total_inherent_revenue = sum(s.get('inherent_market_revenue', 0) for s in sales_stats.values())
        total_gp_revenue = sum(s.get('government_procurement_revenue', 0) for s in sales_stats.values())
        
        if total_revenue > 0:
            household_ratio = (total_household_revenue / total_revenue) * 100
            inherent_ratio = (total_inherent_revenue / total_revenue) * 100
            gp_ratio = (total_gp_revenue / total_revenue) * 100
            print(f"ğŸ’° æ”¶å…¥ç»Ÿè®¡: æ€»æ”¶å…¥${total_revenue:.2f} | "
                  f"å®¶åº­è´­ä¹°${total_household_revenue:.2f} ({household_ratio:.1f}%) | "
                  f"æ”¿åºœé‡‡è´­${total_gp_revenue:.2f} ({gp_ratio:.1f}%) | "
                  f"å›ºæœ‰å¸‚åœº${total_inherent_revenue:.2f} ({inherent_ratio:.1f}%)")
        
        if sales_stats:
            # æ˜¾ç¤ºé”€é‡æœ€é«˜çš„3ä¸ªå•†å“-ä¼ä¸šç»„åˆï¼Œå¹¶åŒºåˆ†å®¶åº­å’Œå›ºå®šå¸‚åœº
            top_sales = sorted(sales_stats.items(), key=lambda x: x[1]['quantity_sold'], reverse=True)[:3]
            for (product_id, seller_id), stats in top_sales:
                household_rev = stats.get('household_revenue', 0)
                inherent_rev = stats.get('inherent_market_revenue', 0)
                gp_rev = stats.get('government_procurement_revenue', 0)
                total_rev = stats['revenue']
                hh_ratio = (household_rev / total_rev * 100) if total_rev > 0 else 0
                in_ratio = (inherent_rev / total_rev * 100) if total_rev > 0 else 0
                gp_ratio = (gp_rev / total_rev * 100) if total_rev > 0 else 0
                
                print(f"   - {product_id}@{seller_id}: æ€»é”€é‡{stats['quantity_sold']:.1f} "
                      f"(å®¶åº­:{stats['household_quantity']:.1f} | æ”¿åºœé‡‡è´­:{stats.get('government_procurement_quantity', 0.0):.1f} | å›ºæœ‰å¸‚åœº:{stats['inherent_market_quantity']:.1f}), "
                      f"æ€»æ”¶å…¥${total_rev:.2f} (å®¶åº­:${household_rev:.2f} {hh_ratio:.1f}% | "
                      f"æ”¿åºœ:${gp_rev:.2f} {gp_ratio:.1f}% | å›ºæœ‰:${inherent_rev:.2f} {in_ratio:.1f}%)")
        return sales_stats

    async def initialize_month1_inventory_by_market_target(
        self,
        month: int,
        firms: List[Any],
        product_market,
        market_total_value_target_ex_tax: float,
        sector_revenue_weights: Dict[str, float],
        powerlaw_alpha: float = 1.15,
        random_state: int = 42,
    ) -> Dict[str, Any]:
        """
        æœˆåˆåˆå§‹åŒ–ï¼ˆç¬¬ä¸€ä¸ªæœˆï¼‰ï¼šæŒ‰â€œå¸‚åœºæ€»ä»·å€¼ç›®æ ‡ + è¡Œä¸šé”€å”®é¢æƒé‡â€åˆ†é…é¢„ç®—ï¼›
        å¯¹æ¯å®¶ä¼ä¸šçš„ SKUï¼Œç”¨å¹‚å¾‹åˆ†é…é¢„ç®—åˆ°å„SKUï¼Œå†æŒ‰ä»·æ ¼æ¢ç®—ä»¶æ•°ï¼ˆåº“å­˜æ•°é‡ï¼‰ã€‚

        è®¾è®¡æ„å›¾ï¼š
        - æ›¿ä»£æ—§çš„â€œå›ºå®šå•†å“æ•°ã€å›ºå®šæ•°é‡â€åˆå§‹åŒ–æ–¹å¼ã€‚
        - SKU çš„é€‰æ‹©/ç¼©å‡åº”åœ¨ä»¿çœŸä¾§å®Œæˆï¼ˆä¾‹å¦‚æŒ‰ sector_sku_weights ç¼©å‡ new_mapï¼‰ï¼Œ
          æ­¤å¤„åªè´Ÿè´£æŠŠâ€œé¢„ç®—â†’ä»¶æ•°â†’åº“å­˜â€è½åˆ°è´¦æœ¬ä¸åº“å­˜ã€‚
        - äº§å‡ºä»·å€¼ä»¥â€œå”®ä»·ä¼°å€¼â€ï¼ˆex taxï¼‰è®¡å…¥ production_statsï¼›
        - å½“å‰ç‰ˆæœ¬ï¼šä¸å†æŠŠâ€œæŒ‰æ¯›åˆ©ç‡ä¼°ç®—çš„å•ä½æˆæœ¬â€ä½œä¸ºä¼ä¸šå½“æœˆç°é‡‘æ”¯å‡ºæ‰£é™¤ï¼ˆåˆ©æ¶¦å£å¾„æ”¹ä¸º å·¥èµ„+æŠ˜æ—§ï¼‰ã€‚
        """
        market_total_value_target_ex_tax = float(market_total_value_target_ex_tax or 0.0)
        if market_total_value_target_ex_tax <= 0:
            raise ValueError("market_total_value_target_ex_tax å¿…é¡»ä¸ºæ­£æ•°ï¼ˆä¸å«ç¨ï¼ŒæŒ‰å”®ä»·ä¼°å€¼ï¼‰")

        # è¡Œä¸šå£å¾„ç»Ÿä¸€ï¼šæŠŠ sector_revenue_weights å…ˆæŒ‰ IO å£å¾„è¡Œä¸šåå½’å¹¶ï¼ˆé¿å…â€œæƒé‡keyä¸ä¼ä¸šè¡Œä¸šåä¸ä¸€è‡´â€ï¼‰
        from agentsociety_ecosim.config.simulation_init_config import normalize_industry

        merged_weights: Dict[str, float] = defaultdict(float)
        for k, v in (sector_revenue_weights or {}).items():
            try:
                w = float(v or 0.0)
            except Exception:
                w = 0.0
            if w <= 0:
                continue
            merged_weights[normalize_industry(str(k))] += w

        revenue_weights = {k: float(v or 0.0) for k, v in merged_weights.items() if float(v or 0.0) > 0}
        if not revenue_weights:
            raise ValueError("sector_revenue_weights ä¸ºç©ºæˆ–å…¨ä¸º0")
        total_w = sum(revenue_weights.values())
        if total_w <= 0:
            raise ValueError("sector_revenue_weights æƒé‡ä¹‹å’Œå¿…é¡»>0")
        revenue_weights = {k: v / total_w for k, v in revenue_weights.items()}

        # firm_id -> sectorï¼ˆç»Ÿä¸€ç”¨ IO å£å¾„è¡Œä¸šåï¼‰
        firm_sector: Dict[str, str] = {}
        for f in firms or []:
            try:
                cid = str(getattr(f, "firm_id"))
                sector = normalize_industry(str(getattr(f, "main_business", "") or getattr(f, "industry", "") or ""))
                if cid:
                    firm_sector[cid] = sector
            except Exception:
                continue

        sector_to_firms: Dict[str, List[str]] = defaultdict(list)
        for cid, sector in firm_sector.items():
            if cid in self.firm_id:
                sector_to_firms[sector].append(cid)

        rng = np.random.default_rng(int(random_state))

        total_output_qty = 0.0
        total_cost_spent = 0.0
        firm_production_qty: Dict[str, float] = {}
        firm_production_cost: Dict[str, float] = {}
        firm_production_value: Dict[str, float] = {}
        products_initialized = 0

        for sector, w in revenue_weights.items():
            firms_in_sector = sector_to_firms.get(sector, [])
            if not firms_in_sector:
                continue

            sector_budget = market_total_value_target_ex_tax * w  # å”®ä»·ä¼°å€¼ï¼ˆä¸å«ç¨ï¼‰
            firm_budget = sector_budget / float(len(firms_in_sector))

            for cid in firms_in_sector:
                prods = self.products.get(cid, []) or []
                if not prods:
                    continue

                n = len(prods)
                order = list(range(n))
                rng.shuffle(order)

                ranks = np.arange(1, n + 1, dtype=float)
                weights = 1.0 / np.power(ranks, float(powerlaw_alpha))
                weights = weights / max(weights.sum(), 1e-12)

                firm_qty = 0.0
                firm_cost = 0.0
                firm_value = 0.0

                for i, idx in enumerate(order):
                    p = prods[idx]
                    price = float(getattr(p, "price", 0.0) or 0.0)
                    if price <= 0:
                        continue

                    alloc_value = firm_budget * float(weights[i])
                    qty = alloc_value / price
                    if qty <= 0:
                        continue

                    # åˆå§‹åŒ–åº“å­˜ï¼šè¦†ç›–ä¸ºç›®æ ‡ä»¶æ•°
                    p.amount = qty
                    products_initialized += 1

                    category = getattr(p, "classification", None) or sector or "Unknown"
                    margin_pct = float(self.category_profit_margins.get(category, 25.0) or 25.0)
                    margin_pct = max(0.0, min(80.0, margin_pct))
                    # å›ºå®šå•ä½æˆæœ¬ï¼šç”±â€œæœ€åˆä»·æ ¼(base_price) + è¡Œä¸šæ¯›åˆ©ç‡â€æ¨å¯¼ï¼Œåç»­ä¸éš price å˜åŠ¨
                    if getattr(p, "base_price", None) is None or float(getattr(p, "base_price", 0.0) or 0.0) <= 0:
                        p.base_price = float(price)
                    unit_cost = float(getattr(p, "unit_cost", 0.0) or 0.0)
                    if unit_cost <= 1e-6:
                        unit_cost = float(p.base_price) * (1.0 - margin_pct / 100.0)
                    if unit_cost <= 1e-9:
                        unit_cost = max(0.01, price * 0.2)
                    p.unit_cost = float(unit_cost)

                    firm_qty += qty
                    firm_value += qty * price
                    # ä¸å†æŠŠ unit_cost è®°ä¸ºå½“æœˆç°é‡‘æ”¯å‡º
                    # firm_cost ä¿ç•™ä¸º0ï¼Œä»…ç”¨äºå…¼å®¹æ—§å­—æ®µ
                    firm_cost += 0.0

                if cid not in self.ledger:
                    self.ledger[cid] = Ledger.create(cid, 0.0)

                firm_production_qty[cid] = firm_qty
                firm_production_cost[cid] = firm_cost
                firm_production_value[cid] = firm_value

                total_output_qty += firm_qty
                total_cost_spent += firm_cost

        await self.sync_product_inventory_to_market(product_market)

        if not hasattr(self, "production_stats_by_month"):
            self.production_stats_by_month = {}
        # æœˆ1åˆå§‹åŒ–é˜¶æ®µï¼šç”¨â€œæœŸåˆåº“å­˜åˆå§‹åŒ–â€ä»£è¡¨å½“æœˆä¾›ç»™ï¼ˆæŒ‰å”®ä»·ä¼°å€¼è®°å…¥ç”Ÿäº§ä¾§ç»Ÿè®¡ï¼‰ã€‚
        # åŒæ—¶ç»Ÿè®¡â€œå½“æ—¶æ˜¯å¦å·²æœ‰é›‡ä½£â€ï¼ˆä¾¿äºæŠ¥è¡¨è§£é‡Šï¼‰ã€‚
        companies_with_workers = 0
        try:
            for f in firms or []:
                if getattr(f, "get_employees", None) and callable(getattr(f, "get_employees")):
                    if int(f.get_employees() or 0) > 0:
                        companies_with_workers += 1
        except Exception:
            companies_with_workers = 0

        total_output_value = 0.0
        try:
            total_output_value = float(sum(float(v or 0.0) for v in firm_production_value.values()) or 0.0)
        except Exception:
            total_output_value = 0.0

        production_stats = {
            "total_companies": len([cid for cid in firm_production_qty.keys()]),
            "companies_with_workers": int(companies_with_workers),
            "base_production_total": total_output_qty,
            "labor_production_total": 0.0,
            "products_restocked": int(products_initialized),
            "firm_base_production": firm_production_qty,
            "firm_production_cost": firm_production_cost,
            "firm_production_value": firm_production_value,
            "total_production_cost": total_cost_spent,
            "total_output_value": total_output_value,
            "init_market_target_ex_tax": market_total_value_target_ex_tax,
            "init_powerlaw_alpha": float(powerlaw_alpha),
        }
        self.production_stats_by_month[month] = production_stats

        self.logger.info(
            f"âœ… Month {month} åˆå§‹åŒ–å®Œæˆ: å¸‚åœºç›®æ ‡(ä¸å«ç¨)=${market_total_value_target_ex_tax:,.2f}, "
            f"åˆå§‹åŒ–SKUæ•°={products_initialized}, äº§å‡º(ä»¶æ•°)={total_output_qty:,.2f}, æˆæœ¬æ”¯å‡º=${total_cost_spent:,.2f}"
        )
        return production_stats
    
    async def execute_monthly_production_cycle(self, month: int, labor_market, product_market, std_jobs, firms: List = None, production_config: Dict = None, innovation_config: Dict = None) -> Dict[str, Any]:
        """
        æ‰§è¡Œæœˆåº¦ç”Ÿäº§å‘¨æœŸ
        1. æ‰€æœ‰å…¬å¸åŸºç¡€ç”Ÿäº§
        2. æœ‰å·¥äººçš„å…¬å¸é¢å¤–ç”Ÿäº§
        3. æ ¹æ®é”€é‡è°ƒæ•´äº§å‡º
        
        Args:
            production_config: ç”Ÿäº§é…ç½®å‚æ•°å­—å…¸ï¼ŒåŒ…å«:
                - base_production_rate: åŸºç¡€è¡¥è´§é‡
                - high_demand_multiplier: é«˜éœ€æ±‚å€æ•°
                - low_demand_multiplier: ä½éœ€æ±‚å€æ•°
                - labor_productivity_factor: åŠ³åŠ¨åŠ›ç”Ÿäº§ç‡
                - labor_elasticity: åŠ³åŠ¨åŠ›å¼¹æ€§
        """
        self.logger.info(f"ğŸ­ å¼€å§‹ç¬¬ {month} æœˆç”Ÿäº§å‘¨æœŸï¼ˆæœˆåˆç”Ÿäº§ï¼‰...")

        # ========= æœˆ1ï¼šä»…æœŸåˆåº“å­˜åˆå§‹åŒ–ï¼ˆä¸èµ°ç”Ÿäº§å‡½æ•°ï¼‰ =========
        # è¯´æ˜ï¼šç”¨æˆ·è¦æ±‚ month=1 åªä½¿ç”¨åˆå§‹å€¼ï¼ˆæ²¡æœ‰ month=0 çš„å‚è€ƒæ•°æ®ï¼‰ï¼Œä¸ä½¿ç”¨ç”Ÿäº§å‡½æ•°äº§å‡ºã€‚
        if month == 1 and isinstance(production_config, dict) and production_config.get("enable_market_target_initial_production", False):
            production_stats = await self.initialize_month1_inventory_by_market_target(
                month=month,
                firms=firms or [],
                product_market=product_market,
                market_total_value_target_ex_tax=float(production_config.get("market_total_value_target_ex_tax", 0.0) or 0.0),
                sector_revenue_weights=dict(production_config.get("sector_revenue_weights", {}) or {}),
                powerlaw_alpha=float(production_config.get("powerlaw_alpha", 1.15) or 1.15),
                random_state=int(production_config.get("random_state", 42) or 42),
            )
            # month=1ï¼šä¸æ‰§è¡ŒCDç”Ÿäº§ï¼ˆä¸ä¾èµ–reference_monthï¼‰ï¼Œä½†â€œåˆå§‹åŒ–åº“å­˜â€æœ¬èº«å·²è®¡å…¥ production_stats çš„ total_output_valueã€‚
            # åŒæ—¶ç»Ÿè®¡â€œé›‡ä½£æƒ…å†µâ€ï¼ˆcompanies_with_workersï¼‰ä¸æœ‰æ•ˆåŠ³åŠ¨åŠ›ï¼ˆä»…ç”¨äºæŠ¥è¡¨è§£é‡Šï¼‰ã€‚
            companies_with_workers = 0
            firm_labor_efficiency = {}
            try:
                for f in firms or []:
                    cid = str(getattr(f, "firm_id", "") or "")
                    if not cid:
                        continue
                    emp = int(f.get_employees() or 0) if getattr(f, "get_employees", None) else 0
                    if emp > 0:
                        companies_with_workers += 1
                    # ä»…ç»Ÿè®¡æœ‰æ•ˆåŠ³åŠ¨åŠ›ï¼Œä¸ç”¨äºç”Ÿäº§
                    try:
                        firm_labor_efficiency[cid] = await self._calculate_effective_labor_force(f, month, std_jobs)
                    except Exception:
                        continue
            except Exception:
                companies_with_workers = 0
                firm_labor_efficiency = {}

            production_stats["companies_with_workers"] = int(companies_with_workers)
            production_stats["firm_labor_efficiency"] = firm_labor_efficiency
            production_stats["labor_production_total"] = 0.0
            # ç¡®ä¿æœˆ1æœ‰ total_output_valueï¼ˆç”¨äºç”Ÿäº§ä¾§GDPå£å¾„ï¼‰
            if "total_output_value" not in production_stats:
                try:
                    pv = production_stats.get("firm_production_value", {}) or {}
                    production_stats["total_output_value"] = float(sum(float(v or 0.0) for v in pv.values()) or 0.0)
                except Exception:
                    production_stats["total_output_value"] = 0.0
            return production_stats

        # âœ¨ åŒæ­¥æœ¬æœˆâ€œæ˜¯å¦å¯ç”¨åˆ›æ–°æ¨¡å—â€å¼€å…³ï¼ˆç”±ä»¿çœŸä¾§ä¼ å…¥ï¼‰
        try:
            self.enable_innovation_module = bool(innovation_config.get("enable_innovation_module", False)) if isinstance(innovation_config, dict) else False
        except Exception:
            self.enable_innovation_module = False

        # å…¼å®¹æ—§å®ä¾‹ï¼šå¦‚æœæ—©æœŸåˆ›å»ºçš„ EconomicCenter æ²¡æœ‰è¯¥å±æ€§ï¼Œè¿™é‡ŒåŠ¨æ€è¡¥ä¸Šï¼Œé¿å… AttributeError
        if not hasattr(self, "production_stats_by_month"):
            self.production_stats_by_month = {}
        production_stats = {
            "total_companies": 0,
            "companies_with_workers": 0,
            "base_production_total": 0.0,
            "labor_production_total": 0.0,
            "products_restocked": 0
        }
        
        # æ ¹æ®self.firm_idç»Ÿè®¡æ€»å…¬å¸æ•°ï¼ˆåªç»Ÿè®¡çœŸæ­£çš„å…¬å¸ï¼‰
        for owner_id in self.firm_id:
            if owner_id in self.products and self.products[owner_id]:
                production_stats["total_companies"] += 1
        
        # ========= æœˆ2+ï¼šç»Ÿä¸€CDç”Ÿäº§ï¼ˆè¾“å‡ºä»·å€¼Vï¼Œå†æ¢ç®—ä»¶æ•°å…¥åº“ï¼‰ =========
        reference_month = month - 1
        sales_data = self.collect_sales_statistics(reference_month) if reference_month >= 1 else {}

        try:
            # 1.5 ä¼ä¸šç¨ç»“ç®—ï¼šç»“ç®—ä¸Šä¸ªæœˆï¼ˆç”¨äºä¸Šæœˆç°é‡‘æµ/ç¨åŸºï¼‰ï¼Œå‘ç”Ÿåœ¨æœ¬æœˆç”Ÿäº§ä¹‹å‰
            if reference_month >= 1:
                self.settle_monthly_corporate_tax(reference_month)

            # ---------- ç»Ÿä¸€CDç”Ÿäº§å‚æ•° ----------
            # é»˜è®¤ Cobbâ€“Douglas æŒ‡æ•°ï¼ˆå¯ç”±ä»¿çœŸä¾§ä¼ å…¥ production_config è¦†ç›–ï¼‰
            try:
                alpha = float((production_config or {}).get("cd_alpha_labor", 0.7) or 0.7)
            except Exception:
                alpha = 0.7
            try:
                beta = float((production_config or {}).get("cd_beta_capital", 0.3) or 0.3)
            except Exception:
                beta = 0.3
            alpha = max(0.0, min(1.0, alpha))
            beta = max(0.0, min(1.0, beta))
            rho = 0.5  # è§„æ¨¡å¼¹æ€§ï¼ˆç”¨äºK_flooræŒ‰å‘˜å·¥è§„æ¨¡ç¼©æ”¾ï¼‰
            u = float((production_config or {}).get("production_budget_utilization_rate", 0.6) or 0.6)
            from agentsociety_ecosim.config.simulation_init_config import normalize_industry

            # åˆå¹¶åˆ° IO å£å¾„è¡Œä¸šæƒé‡
            sector_weights_raw = dict((production_config or {}).get("sector_revenue_weights", {}) or {})
            merged_sector_weights: Dict[str, float] = defaultdict(float)
            for k, v in (sector_weights_raw or {}).items():
                try:
                    w = float(v or 0.0)
                except Exception:
                    w = 0.0
                if w <= 0:
                    continue
                merged_sector_weights[normalize_industry(str(k))] += w
            sector_weights = dict(merged_sector_weights)
            market_total_value_target_ex_tax = float((production_config or {}).get("market_total_value_target_ex_tax", 0.0) or 0.0)
            cd_floor_total_ratio = float((production_config or {}).get("cd_floor_total_ratio", 0.02) or 0.02)
            cd_target_output_value_ratio = float((production_config or {}).get("cd_target_output_value_ratio", 1.0) or 1.0)
            max_skus_per_firm = int((production_config or {}).get("cd_max_skus_per_firm", 200) or 200)
            min_qty_per_sku = float((production_config or {}).get("min_production_per_product", 0.0) or 0.0)

            # firm_id -> sectorï¼ˆç»Ÿä¸€ç”¨ IO å£å¾„è¡Œä¸šåï¼‰
            firm_sector: Dict[str, str] = {}
            for f in firms or []:
                try:
                    cid = str(getattr(f, "firm_id"))
                    sector = normalize_industry(str(getattr(f, "main_business", "") or getattr(f, "industry", "") or ""))
                    if cid:
                        firm_sector[cid] = sector
                except Exception:
                    continue

            # ---------- è®¡ç®—æœ‰æ•ˆåŠ³åŠ¨åŠ›ï¼ˆLï¼‰ ----------
            firm_labor_efficiency: Dict[str, Any] = {}
            L_by_firm: Dict[str, float] = {}
            emp_by_firm: Dict[str, int] = {}
            for f in firms or []:
                cid = str(getattr(f, "firm_id", "") or "")
                if not cid:
                    continue
                try:
                    labor_info = await self._calculate_effective_labor_force(f, month, std_jobs)
                except Exception:
                    labor_info = {"total_employees": 0, "production_effective_labor": 0.0, "effective_labor": 0.0, "avg_match_score": 0.0, "skill_details": []}
                firm_labor_efficiency[cid] = labor_info
                emp = int(labor_info.get("total_employees", 0) or 0)
                emp_by_firm[cid] = emp
                # ä½¿ç”¨â€œç”Ÿäº§æœ‰æ•ˆåŠ³åŠ¨åŠ›â€ï¼ˆå·²æ‰£é™¤ç ”å‘å æ¯”ï¼‰
                L_by_firm[cid] = float(labor_info.get("production_effective_labor", 0.0) or 0.0)

            avg_emp = (sum(emp_by_firm.values()) / max(1, len(emp_by_firm))) if emp_by_firm else 1.0

            # ---------- è®¡ç®—Kï¼ˆå¯æŠ•å…¥é¢„ç®—ï¼‰ ----------
            # K = K_floor(è¡Œä¸šæƒé‡*è§„æ¨¡) + u*income_{t-1}
            income_prev_by_firm: Dict[str, float] = {}
            total_income_prev = 0.0
            for cid in list(self.firm_id):
                inc = float(self.firm_monthly_financials.get(cid, {}).get(reference_month, {}).get("income", 0.0) or 0.0)
                income_prev_by_firm[cid] = inc
                total_income_prev += inc

            # æ€»ä¿åº•æŠ•å…¥è§„æ¨¡ï¼šä¼˜å…ˆç”¨ market_total_value_target_ex_tax ä½œä¸ºåŸºå‡†ï¼Œå¦åˆ™é€€åŒ–åˆ°ä¸Šæœˆæ€»æ”¶å…¥
            baseline = market_total_value_target_ex_tax if market_total_value_target_ex_tax > 0 else max(1.0, total_income_prev)
            total_floor_budget = baseline * cd_floor_total_ratio

            def _sector_w(cid: str) -> float:
                sector = firm_sector.get(cid, "") or ""
                sector = normalize_industry(sector)
                w = float(sector_weights.get(sector, 0.0) or 0.0)
                return w if w > 0 else 1.0

            raw_weights: Dict[str, float] = {}
            for cid in list(self.firm_id):
                emp = max(1, int(emp_by_firm.get(cid, 0) or 0))
                scale = (emp / max(1e-9, float(avg_emp))) ** rho
                raw_weights[cid] = _sector_w(cid) * scale
            sum_raw = sum(raw_weights.values()) if raw_weights else 1.0

            K_by_firm: Dict[str, float] = {}
            for cid in list(self.firm_id):
                k_floor = total_floor_budget * (raw_weights.get(cid, 1.0) / max(1e-12, sum_raw))
                k_var = u * float(income_prev_by_firm.get(cid, 0.0) or 0.0)
                K_by_firm[cid] = max(1e-9, k_floor + k_var)

            # ---------- è¯»å– Month1 CD æ ¡å‡†å‚æ•°ï¼ˆè‹¥å­˜åœ¨åˆ™ä¼˜å…ˆä½¿ç”¨ï¼Œä¸”åç»­æœˆä»½ä¸å†å˜åŒ–ï¼‰ ----------
            use_fixed_cd = bool(getattr(self, "_cd_industry_A", None)) and bool(getattr(self, "_cd_firm_K", None))

            # ---------- A çš„å¼±åé¦ˆæ›´æ–°ï¼ˆæ–¹æ¡ˆ2ï¼šé™å¹…æ…¢å˜ï¼Œé¿å…â€œæ¯æœˆå¼ºè¡Œæ ¡å‡†â€ï¼‰ ----------
            # æ€è·¯ï¼š
            # - ç»´æŠ¤è·¨æœˆçš„ A_prevï¼ˆå…¨å±€æŠ€æœ¯æ°´å¹³ï¼‰
            # - ä»…åœ¨åˆæ¬¡éœ€è¦æ—¶ï¼ˆé€šå¸¸ month=2ï¼‰ç»™ä¸€ä¸ªåˆç†åˆå€¼ï¼ˆå¯ç”¨ç›®æ ‡/åŸºå‡†åæ¨ä¸€æ¬¡ï¼‰
            # - ä¹‹åæ¯æœˆæ ¹æ® gap åšå°å¹…æ›´æ–°ï¼šA_t = A_{t-1} * clip(1 + gamma*gap, 1-delta, 1+delta)
            # å…¶ä¸­ gap = (target/base_sum - 1)ï¼Œdelta æ§åˆ¶â€œæ¯æœˆæœ€å¤§è°ƒæ•´å¹…åº¦â€ï¼Œgamma æ§åˆ¶åé¦ˆå¼ºåº¦
            cd_A_max_step = float((production_config or {}).get("cd_A_max_step", 0.02) or 0.02)  # æ¯æœˆæœ€å¤šÂ±2%
            cd_A_feedback_gamma = float((production_config or {}).get("cd_A_feedback_gamma", 0.1) or 0.1)

            base_sum = 0.0
            for cid in list(self.firm_id):
                L = max(0.0, float(L_by_firm.get(cid, 0.0) or 0.0))
                # base_sum åªç”¨äºâ€œå…¨å±€Aå¼±åé¦ˆâ€çš„ä¼°ç®—ï¼›è‹¥ä½¿ç”¨å›ºå®šCDï¼Œåˆ™å…¨å±€Aä¸å‚ä¸ç”Ÿäº§ä½†ä»å¯ä¿ç•™ç»Ÿè®¡
                K_cap = None
                try:
                    k_bs = float(self.firm_capital_stock.get(cid, 0.0) or 0.0)
                    if k_bs > 0:
                        K_cap = k_bs
                except Exception:
                    K_cap = None
                if K_cap is None and use_fixed_cd:
                    try:
                        K_cap = float(self._cd_firm_K.get(cid, 0.0) or 0.0)
                    except Exception:
                        K_cap = None
                K = max(1e-9, float(K_cap if (K_cap is not None and K_cap > 0) else (K_by_firm.get(cid, 1e-9) or 1e-9)))
                if L <= 0:
                    continue
                base_sum += (L ** alpha) * (K ** beta)
            target_total_V = max(1.0, total_income_prev) * cd_target_output_value_ratio

            # 1) åˆå§‹åŒ– A_prevï¼ˆé¦–æ¬¡è¿›å…¥CDç”Ÿäº§æ—¶ï¼‰
            if not hasattr(self, "_cd_global_A") or getattr(self, "_cd_global_A") is None:
                # ç»™ä¸€ä¸ªåˆç†åˆå€¼ï¼šè‹¥ base_sum å¯ç”¨ï¼Œåˆ™ç”¨ä¸€æ¬¡æ€§åæ¨ï¼›å¦åˆ™ç”¨1
                self._cd_global_A = (target_total_V / base_sum) if base_sum > 1e-12 else 1.0

            A_prev = float(getattr(self, "_cd_global_A") or 1.0)

            # 2) å¼±åé¦ˆæ›´æ–°ï¼ˆé™å¹…æ…¢å˜ï¼‰
            if base_sum > 1e-12 and A_prev > 0:
                ratio = target_total_V / base_sum
                gap = ratio - 1.0
                # é™å¹…ï¼šæ¯æœˆæœ€å¤šæŒ‰Â±cd_A_max_stepè°ƒæ•´
                step = 1.0 + cd_A_feedback_gamma * gap
                step = max(1.0 - cd_A_max_step, min(1.0 + cd_A_max_step, step))
                A = A_prev * step
            else:
                # base_sumä¸å¯ç”¨æˆ–A_prevå¼‚å¸¸æ—¶ï¼Œä¸æ›´æ–°
                A = max(0.0, A_prev)

            # å†™å›ç¼“å­˜ï¼Œä¾›ä¸‹æœˆç»§ç»­ä½¿ç”¨
            self._cd_global_A = float(A)
            print('==============================================')
            print(f'åˆå§‹è®¾ç½®çš„A: {A}')
            print('==============================================')
            # ---------- è®¡ç®—æ¯ä¼ä¸šäº§å‡ºä»·å€¼Vå¹¶åˆ†é…åˆ°SKU ----------
            total_qty = 0.0
            total_output_value = 0.0
            total_cost_spent = 0.0
            products_restocked = 0
            companies_with_workers = sum(1 for cid, emp in emp_by_firm.items() if emp > 0)

            firm_production_qty: Dict[str, float] = {}
            firm_production_cost: Dict[str, float] = {}
            firm_production_value: Dict[str, float] = {}

            # é¢„è®¡ç®—æ¯ä¸ª firm çš„â€œä¸Šæœˆæ€»é”€é‡â€ï¼ˆç”¨äºåº“å­˜ç›®æ ‡çš„ç²—ç•¥ç¼ºå£ï¼‰
            firm_sales_qty_prev: Dict[str, float] = {}
            for (pid, seller_id), info in (sales_data or {}).items():
                try:
                    firm_sales_qty_prev[str(seller_id)] = firm_sales_qty_prev.get(str(seller_id), 0.0) + float(info.get("quantity_sold", 0.0) or 0.0)
                except Exception:
                    continue

            for cid in list(self.firm_id):
                prods = self.products.get(cid, []) or []
                if not prods:
                    firm_production_qty[cid] = 0.0
                    firm_production_cost[cid] = 0.0
                    firm_production_value[cid] = 0.0
                    continue

                L = max(0.0, float(L_by_firm.get(cid, 0.0) or 0.0))
                # ç”Ÿäº§çš„â€œèµ„æœ¬è¾“å…¥K_capitalâ€ä¼˜å…ˆä½¿ç”¨ä¼ä¸šèµ„æœ¬å­˜é‡ï¼ˆfirm_capital_stockï¼Œç”¨ä½œCD-Kï¼‰
                K_capital = None
                try:
                    k_bs = float(self.firm_capital_stock.get(cid, 0.0) or 0.0)
                    if k_bs > 0:
                        K_capital = k_bs
                except Exception:
                    K_capital = None
                if K_capital is None and use_fixed_cd:
                    try:
                        K_capital = float(self._cd_firm_K.get(cid, 0.0) or 0.0)
                    except Exception:
                        K_capital = None
                K_cap = max(1e-9, float(K_capital if (K_capital is not None and K_capital > 0) else (K_by_firm.get(cid, 1e-9) or 1e-9)))

                # ç”Ÿäº§ç‡Aï¼šä¼˜å…ˆä½¿ç”¨ä¼ä¸šå›ºåŒ– A_iï¼ˆè‹¥æœ‰ï¼‰ï¼›å¦åˆ™ç”¨è¡Œä¸šå›ºåŒ– A_sï¼›å¦åˆ™å›é€€å…¨å±€ A
                if use_fixed_cd:
                    A_use = 0.0
                    try:
                        a_i = float(getattr(self, "_cd_firm_A", {}).get(cid, 0.0) or 0.0)
                        if a_i > 0:
                            A_use = a_i
                    except Exception:
                        A_use = 0.0

                    if A_use <= 0:
                        sector = firm_sector.get(cid, "") or ""
                        try:
                            a_s = float(self._cd_industry_A.get(sector, 0.0) or 0.0)
                            if a_s > 0:
                                A_use = a_s
                        except Exception:
                            A_use = 0.0

                    if A_use <= 0:
                        A_use = float(A)
                else:
                    A_use = float(A)

                V = float(A_use) * (L ** alpha) * (K_cap ** beta) if (A_use > 0 and L > 0) else 0.0

                # è‹¥æ²¡æœ‰åŠ³åŠ¨åŠ›ï¼Œä»å…è®¸ç”¨K_flooräº§ç”Ÿå°‘é‡ä¾›ç»™ï¼ˆå¯é€‰ï¼‰ï¼›è¿™é‡ŒæŒ‰ç”¨æˆ·è®¾å®šï¼šL=0åˆ™V=0
                if V <= 1e-12:
                    firm_production_qty[cid] = 0.0
                    firm_production_cost[cid] = 0.0
                    firm_production_value[cid] = 0.0
                    continue

                # SKUæƒé‡ï¼šé”€é‡ + åº“å­˜ç¼ºå£ï¼ˆç›®æ ‡åº“å­˜=ä¸Šæœˆé”€é‡*(1+buffer)+1ï¼‰
                buffer_ratio = 0.5
                weights = []
                for p in prods:
                    price = float(getattr(p, "price", 0.0) or 0.0)
                    if price <= 0:
                        continue
                    pid = getattr(p, "product_id", None)
                    sold = 0.0
                    if pid:
                        info = (sales_data.get((pid, cid), {}) or {})
                        # âœ… éœ€æ±‚ä¿¡å·ï¼šå®¶åº­é”€é‡ + Î»*æœªæ»¡è¶³éœ€æ±‚ï¼ˆé¿å…â€œå›ºæœ‰å¸‚åœºå‡ºæ¸…â€æŠŠé”€é‡å˜æˆäº§é‡ï¼‰
                        hh_sold = float(info.get("household_quantity", info.get("quantity_sold", 0.0)) or 0.0)
                        unmet_short = float(info.get("unmet_qty_short", 0.0) or 0.0)
                        try:
                            unmet_lambda = float((production_config or {}).get("unmet_demand_lambda", 1.0) or 1.0)
                        except Exception:
                            unmet_lambda = 1.0
                        unmet_lambda = max(0.0, min(10.0, unmet_lambda))
                        sold = hh_sold + unmet_lambda * unmet_short
                    stock = float(getattr(p, "amount", 0.0) or 0.0)
                    target_stock = sold * (1.0 + buffer_ratio) + 1.0
                    gap = max(0.0, target_stock - stock)
                    w = 1.0 + sold + gap
                    weights.append((p, w, sold, gap))

                if not weights:
                    firm_production_qty[cid] = 0.0
                    firm_production_cost[cid] = 0.0
                    firm_production_value[cid] = 0.0
                    continue

                # é™åˆ¶å‚ä¸è¡¥è´§çš„SKUæ•°é‡ï¼Œé¿å…ä»·å€¼è¢«ç¨€é‡Šåˆ°è¿‡å¤šSKUå¯¼è‡´â€œæ¯ä¸ªSKUéƒ½å¤ªå°â€
                weights.sort(key=lambda x: x[1], reverse=True)
                weights = weights[:max_skus_per_firm]
                sum_w = sum(w for _, w, _, _ in weights) or 1.0

                # å…ˆæŒ‰ä»·å€¼åˆ†é…ï¼ˆv_allocï¼‰ï¼Œå†æ¢ç®—ä»¶æ•°ï¼šqty = v_alloc / price
                planned = []
                for p, w, _, _ in weights:
                    price = float(getattr(p, "price", 0.0) or 0.0)
                    if price <= 0:
                        continue
                    v_alloc = V * (w / sum_w)
                    qty = v_alloc / price
                    if min_qty_per_sku > 0 and qty < min_qty_per_sku:
                        continue
                    # å½“å‰ç‰ˆæœ¬ï¼šç”Ÿäº§ä¸å†éœ€è¦é¢å¤–â€œä¸­é—´æŠ•å…¥æˆæœ¬/ç°é‡‘é¢„ç®—â€ï¼Œåˆ©æ¶¦å£å¾„æ”¹ä¸º å·¥èµ„+æŠ˜æ—§
                    planned.append((p, qty, v_alloc))

                if not planned:
                    firm_production_qty[cid] = 0.0
                    firm_production_cost[cid] = 0.0
                    firm_production_value[cid] = 0.0
                    continue

                scale = 1.0

                firm_qty = 0.0
                firm_value = 0.0
                firm_cost = 0.0
                for p, qty, v_alloc in planned:
                    qty2 = qty * scale
                    if qty2 <= 1e-9:
                        continue
                    p.amount += qty2
                    firm_qty += qty2
                    firm_value += v_alloc * scale
                    firm_cost += 0.0
                    products_restocked += 1

                firm_production_qty[cid] = firm_qty
                firm_production_cost[cid] = firm_cost
                firm_production_value[cid] = firm_value

                total_qty += firm_qty
                total_output_value += firm_value
                total_cost_spent += firm_cost

            # å†™å…¥production_statsï¼ˆç»Ÿä¸€å£å¾„ï¼šCDäº§å‡º=base_production_totalï¼ŒåŠ³åŠ¨åŠ›äº§å‡º=0ï¼‰
            production_stats["companies_with_workers"] = companies_with_workers
            production_stats["firm_labor_efficiency"] = firm_labor_efficiency
            production_stats["base_production_total"] = total_qty
            production_stats["labor_production_total"] = 0.0
            production_stats["products_restocked"] = int(products_restocked)
            production_stats["firm_base_production"] = firm_production_qty
            production_stats["firm_production_cost"] = firm_production_cost
            production_stats["firm_production_value"] = firm_production_value
            production_stats["total_production_cost"] = float(total_cost_spent)
            # æ–°å¢ï¼šç»Ÿä¸€CDç”Ÿäº§å£å¾„çš„â€œäº§å‡ºæ€»ä»·å€¼â€ï¼ˆç”¨äºç”Ÿäº§ä¾§GDPï¼‰
            production_stats["total_output_value"] = float(total_output_value)
            production_stats["cd_params"] = {
                "alpha": alpha,
                "beta": beta,
                "rho": rho,
                "u": u,
                "A": float(A),
                "target_total_output_value": float(target_total_V),
                "total_floor_budget": float(total_floor_budget),
                "floor_total_ratio": float(cd_floor_total_ratio),
                "target_output_value_ratio": float(cd_target_output_value_ratio),
                "max_skus_per_firm": int(max_skus_per_firm),
                # å¼±åé¦ˆå‚æ•°ï¼ˆæ–¹æ¡ˆ2ï¼‰
                "A_prev": float(A_prev) if "A_prev" in locals() else float(A),
                "A_max_step": float(cd_A_max_step),
                "A_feedback_gamma": float(cd_A_feedback_gamma),
            }

            # 5. åŒæ­¥åº“å­˜åˆ°ProductMarket
            await self.sync_product_inventory_to_market(product_market)

            self.logger.info(f"âœ… ç¬¬ {month} æœˆç”Ÿäº§å‘¨æœŸå®Œæˆï¼ˆç»Ÿä¸€CDï¼‰")
            self.logger.info(f"   CDäº§å‡º(ä»¶æ•°): {total_qty:.2f} | CDäº§å‡ºä»·å€¼: ${total_output_value:,.2f} | æˆæœ¬æ”¯å‡º: ${total_cost_spent:,.2f}")

            # ç¼“å­˜æœ¬æœˆç”Ÿäº§ç»Ÿè®¡
            self.production_stats_by_month[month] = production_stats
            return production_stats
            
        except Exception as e:
            self.logger.error(f"âŒ ç¬¬ {month} æœˆç”Ÿäº§å‘¨æœŸå¤±è´¥: {e}")
            # å¤±è´¥ä¹Ÿç¼“å­˜ï¼Œä¾¿äºåç»­è¯Šæ–­
            self.production_stats_by_month[month] = production_stats
            return production_stats


    # =========================================================================
    # Corporate Tax & Financial Settlement
    # =========================================================================
    def settle_monthly_corporate_tax(self, month: int) -> Dict[str, float]:
        """
        æœˆåº¦ä¼ä¸šæ‰€å¾—ç¨ç»“ç®—ï¼ˆæŒ‰å‡€åˆ©æ¶¦è®¡ç¨ï¼‰ã€‚

        ç»“ç®—æ—¶ç‚¹ï¼šåº”åœ¨â€œå·¥èµ„å‘æ”¾å®Œæˆåã€ç”Ÿäº§è¡¥è´§å¼€å§‹å‰â€æ‰§è¡Œï¼Œä»¥ä¾¿ç”Ÿäº§é¢„ç®—ä¸Šé™ä¸ºï¼š
        income - corporate_tax - wagesã€‚

        ç¨åŸºå£å¾„ï¼ˆç°é‡‘æµ/è´¹ç”¨å‘ç”Ÿåˆ¶ï¼Œä¸ä½ å½“å‰â€œå½“æœˆæˆæœ¬Kåœ¨ç”Ÿäº§é˜¶æ®µè®°æ”¯å‡ºâ€çš„è®°è´¦ä¸€è‡´ï¼‰ï¼š
        - ç¨å‰åˆ©æ¶¦ = å½“æœˆæ€»æ”¶å…¥ âˆ’ å½“æœˆæ€»æ”¯å‡ºï¼ˆå·¥èµ„/ç”Ÿäº§æˆæœ¬/å…¶å®ƒè´¹ç”¨ï¼Œä¸å«ä¼ä¸šç¨ï¼‰
        - ç¨é¢ = max(0, ç¨å‰åˆ©æ¶¦) Ã— corporate_tax_rate

        æ³¨æ„ï¼šå¦‚æœä½ å¸Œæœ›æŠŠâ€œæœªå”®å‡ºåº“å­˜çš„ç”Ÿäº§æˆæœ¬â€èµ„æœ¬åŒ–ï¼ˆç”¨ COGS/åº“å­˜å˜åŠ¨æ¥æ ¸ç®—åˆ©æ¶¦ï¼‰ï¼Œ
        è¿™é‡Œçš„ç¨åŸºä¹Ÿåº”åŒæ­¥åˆ‡æ¢ä¸ºâ€œæ”¶å…¥âˆ’é”€è´§æˆæœ¬âˆ’å·¥èµ„â€¦â€çš„å£å¾„ã€‚
        """
        if month in self._corporate_tax_settled_months:
            return {}

        results: Dict[str, float] = {}
        gov_id = "gov_main_simulation"
        if gov_id not in self.ledger:
            # è‹¥æ”¿åºœè´¦æœ¬æœªåˆå§‹åŒ–ï¼Œç›´æ¥è·³è¿‡ï¼ˆé¿å…å´©æºƒï¼‰
            self._corporate_tax_settled_months.add(month)
            return results

        for firm_id in list(self.firm_id):
            if firm_id not in self.ledger:
                self.ledger[firm_id] = Ledger.create(firm_id, 0.0)

            income = float(self.firm_monthly_financials.get(firm_id, {}).get(month, {}).get("income", 0.0) or 0.0)
            expenses_pre_tax = float(self.firm_monthly_financials.get(firm_id, {}).get(month, {}).get("expenses", 0.0) or 0.0)
            taxable_profit = max(0.0, income - expenses_pre_tax)
            corporate_tax = taxable_profit * float(self.corporate_tax_rate or 0.0)

            if corporate_tax <= 1e-9:
                results[firm_id] = 0.0
                continue

            # ğŸ”§ ä¿®æ”¹ï¼šå…è®¸ä¼ä¸šè´Ÿå€ºç¼´ç¨ï¼Œå³ä½¿ä½™é¢ä¸ºè´Ÿä¹Ÿè¦æ‰£ç¨
            # è¿™æ ·å¯ä»¥æ¨¡æ‹Ÿä¼ä¸šå³ä½¿äºæŸä¹Ÿéœ€è¦ç¼´çº³ä¼ä¸šæ‰€å¾—ç¨çš„æƒ…å†µ
            if self.ledger[firm_id].amount < corporate_tax:
                self.logger.info(f"ğŸ’³ Company {firm_id} paying tax with insufficient balance: "
                          f"${self.ledger[firm_id].amount:.2f} â†’ ${self.ledger[firm_id].amount - corporate_tax:.2f}")
            
            # ç›´æ¥æ‰£ç¨ï¼Œå…è®¸ä½™é¢å˜ä¸ºè´Ÿæ•°
            # å¦‚æœä¼ä¸šåŸæœ¬å°±æ˜¯è´Ÿå€ºï¼Œä¼šè¿›ä¸€æ­¥å¢åŠ è´Ÿå€º
            self.ledger[firm_id].amount -= corporate_tax
            self.ledger[gov_id].amount += corporate_tax

            # è´¦åŠ¡è®°å½•
            self.record_firm_expense(firm_id, corporate_tax)
            self.record_firm_monthly_expense(firm_id, month, corporate_tax)
            self.firm_monthly_corporate_tax[firm_id][month] += corporate_tax

            corp_tax_tx = self._record_transaction(
                sender_id=firm_id,
                receiver_id=gov_id,
                amount=corporate_tax,
                tx_type='corporate_tax',
                month=month,
                metadata={
                    "taxable_profit": taxable_profit,
                    "tax_rate": self.corporate_tax_rate,
                    "income": income,
                    "expenses_pre_tax": expenses_pre_tax,
                },
            )
            results[firm_id] = corporate_tax

        self._corporate_tax_settled_months.add(month)
        return results

    async def _execute_base_production_for_all_firms(
        self,
        production_month: int,
        reference_month: int,
        sales_data: Dict,
        firms: List = None,
        std_jobs=None,
        production_config: Dict = None,
    ) -> Dict[str, Any]:
        """
        âœ¨ ç®€åŒ–ç‰ˆç”Ÿäº§ç³»ç»Ÿï¼šç›´æ¥æ ¹æ®åˆ©æ¶¦é‡‘é¢ç”Ÿäº§

        æ ¸å¿ƒé€»è¾‘ï¼š
        1. åŒºåˆ†ä¸¤ç±»å•†å“ï¼šå®¶åº­å¸‚åœºå•†å“ vs å›ºæœ‰å¸‚åœºå•†å“
        2. å®¶åº­é”€å”®è·å¾—çš„åˆ©æ¶¦100%ç”¨äºå®¶åº­å•†å“ç”Ÿäº§
        3. å›ºæœ‰å¸‚åœºè·å¾—çš„åˆ©æ¶¦100%ç”¨äºå›ºæœ‰å¸‚åœºå•†å“ç”Ÿäº§
        4. ç”Ÿäº§ä»¶æ•° = åˆ©æ¶¦ / (å”®ä»· Ã— (1 - æ¯›åˆ©ç‡))
           ä¾‹å¦‚ï¼šåˆ©æ¶¦100ï¼Œå”®ä»·10ï¼Œæ¯›åˆ©ç‡0.4 â†’ æˆæœ¬=10Ã—0.6=6 â†’ ç”Ÿäº§ä»¶æ•° = 100 / 6 â‰ˆ 16.67ä»¶
        5. æŒ‰å•†å“åˆ©æ¶¦ä¼˜å…ˆçº§åˆ†é…ç”Ÿäº§

        Args:
            production_month: æœ¬æ¬¡ç”Ÿäº§å‘ç”Ÿçš„æœˆä»½ï¼ˆæˆæœ¬è®°è´¦æœˆä»½ï¼‰
            reference_month: ç”¨äºæŒ‡å¯¼ç”Ÿäº§é¢„ç®—çš„å‚è€ƒæœˆä»½ï¼ˆé€šå¸¸ä¸ºä¸Šä¸ªæœˆï¼›month=1 æ—¶ä¸º 0ï¼‰
        """
        total_output = 0.0
        products_restocked = 0
        firm_production = {}  # å®é™…ç”Ÿäº§æ•°é‡ï¼ˆä»¶æ•°/å•ä½ï¼‰
        firm_production_cost = {}  # æœ¬æœˆç”Ÿäº§æˆæœ¬æ”¯å‡ºï¼ˆç°é‡‘ï¼‰
        firm_production_value = {}  # æœ¬æœˆç”Ÿäº§äº§å‡ºæŒ‰å”®ä»·ä¼°å€¼çš„æ€»ä»·å€¼

        min_production_per_product = 0.0
        if isinstance(production_config, dict):
            try:
                min_production_per_product = float(production_config.get("min_production_per_product", 0.0) or 0.0)
            except Exception:
                min_production_per_product = 0.0

        total_cost_spent = 0.0

        # éå†æ‰€æœ‰å…¬å¸
        for owner_id, products in self.products.items():
            if not products:
                continue
            if owner_id not in self.firm_id:
                continue

            # 1) ç”Ÿäº§é¢„ç®—ä¸Šé™ï¼šå‚è€ƒæœˆæ”¶å…¥ - å‚è€ƒæœˆä¼ä¸šç¨ - å‚è€ƒæœˆå·¥èµ„æ”¯å‡º
            #    ï¼ˆæœˆåˆç”Ÿäº§ï¼šç”¨ä¸Šä¸ªæœˆåˆ©æ¶¦/ç°é‡‘æµæŒ‡å¯¼æœ¬æœˆè¡¥è´§ï¼‰
            if reference_month >= 1:
                monthly_income = float(self.firm_monthly_financials.get(owner_id, {}).get(reference_month, {}).get("income", 0.0) or 0.0)
                monthly_corp_tax = float(self.firm_monthly_corporate_tax.get(owner_id, {}).get(reference_month, 0.0) or 0.0)
                monthly_wages = float(self.firm_monthly_wage_expenses.get(owner_id, {}).get(reference_month, 0.0) or 0.0)
            else:
                monthly_income = 0.0
                monthly_corp_tax = 0.0
                monthly_wages = 0.0

            budget_upper_raw = max(0.0, monthly_income - monthly_corp_tax - monthly_wages)
            # ğŸ†• åº”ç”¨ç”Ÿäº§é¢„ç®—ä½¿ç”¨ç‡ï¼ˆé»˜è®¤80%ï¼Œç•™20%ä½œä¸ºåˆ©æ¶¦ï¼‰
            production_budget_rate = float(production_config.get('production_budget_utilization_rate', 0.8) if production_config else 0.8)
            budget_upper = budget_upper_raw * production_budget_rate
            # ğŸ”§ å¤§ä¿®ï¼šå…è®¸ä¼ä¸šè´Ÿå€ºç»è¥æ—¶ï¼Œç”Ÿäº§æˆæœ¬ä¹Ÿå…è®¸è®©ä½™é¢ä¸ºè´Ÿ
            # ç”Ÿäº§é¢„ç®— = ä¸Šæœˆåˆ©æ¶¦é¢„ç®—ä¸Šé™ï¼ˆä¸å†å—å½“å‰ç°é‡‘ä½™é¢é™åˆ¶ï¼‰
            production_budget = budget_upper

            if production_budget <= 1e-6:
                firm_production[owner_id] = 0.0
                firm_production_cost[owner_id] = 0.0
                firm_production_value[owner_id] = 0.0
                continue

            # 2) æŒ‰â€œé”€é‡æƒé‡â€åˆ†é…ç”Ÿäº§é¢„ç®—ï¼ˆé”€é‡è¶Šé«˜æƒé‡è¶Šå¤§ï¼›æ— é”€é‡ä¹Ÿä¿åº•1ï¼‰
            #    ğŸ†• åŠ å…¥â€œæœªæ»¡è¶³éœ€æ±‚â€é—­ç¯ï¼šw ~ sold_qty + Î» * unmet_qty_short
            unmet_lambda = 1.0
            if isinstance(production_config, dict):
                try:
                    unmet_lambda = float(production_config.get("unmet_demand_lambda", 1.0) or 1.0)
                except Exception:
                    unmet_lambda = 1.0
            unmet_lambda = max(0.0, float(unmet_lambda))

            unmet_month = {}
            try:
        # ===== Unmet Demand Tracking =====
                unmet_month = dict(self.unmet_demand_by_month.get(int(reference_month), {}) or {})
            except Exception:
                unmet_month = {}

            weights = {}
            total_weight = 0.0
            for p in products:
                try:
                    sales_key = (p.product_id, owner_id)
                    qty_sold = float((sales_data.get(sales_key, {}) or {}).get("quantity_sold", 0.0) or 0.0)
                except Exception:
                    qty_sold = 0.0
                unmet_key = self._unmet_key(getattr(p, "product_id", ""), owner_id)
                try:
                    unmet_short = float((unmet_month.get(unmet_key, {}) or {}).get("qty_short", 0.0) or 0.0)
                except Exception:
                    unmet_short = 0.0
                effective_demand = max(0.0, qty_sold) + unmet_lambda * max(0.0, unmet_short)
                w = max(1.0, effective_demand)
                weights[p.product_id] = w
                total_weight += w

            if total_weight <= 0:
                total_weight = float(len(products))

            # 3) ç”Ÿäº§ï¼šç”¨é¢„ç®—è´­ä¹°â€œä¸‹æœˆåº“å­˜â€ï¼ˆæœ¬æœˆè®° production_cost æ”¯å‡ºï¼‰
            firm_qty = 0.0
            firm_cost = 0.0
            firm_value = 0.0

            for p in products:
                if not getattr(p, "price", None) or p.price <= 0:
                    continue
                # ä½¿ç”¨ç¨³å®šå•ä½æˆæœ¬ï¼ˆbase_price æ¨å¯¼ï¼‰ï¼Œé¿å…ä»·æ ¼è°ƒæ•´å¯¼è‡´â€œæˆæœ¬éšå”®ä»·å˜åŠ¨â€
                self._ensure_product_cost_fields(p)
                unit_cost = float(getattr(p, "unit_cost", 0.0) or 0.0)
                if unit_cost <= 1e-6:
                    unit_cost = max(0.01, float(getattr(p, "base_price", p.price) or p.price) * 0.2)

                alloc_budget = production_budget * (weights.get(p.product_id, 1.0) / total_weight)
                # é¿å…å¯¹è¶…å¤šå•†å“åšæå°è¡¥è´§ï¼šåªæœ‰åˆ†é…é¢„ç®—è¶³å¤Ÿè¦†ç›–â€œæœ€å°ç”Ÿäº§é‡æˆæœ¬â€æ‰ç”Ÿäº§
                if min_production_per_product > 0 and alloc_budget < unit_cost * min_production_per_product:
                    continue

                qty = alloc_budget / unit_cost
                if qty <= 1e-6:
                    continue

                p.amount += qty
                firm_qty += qty
                firm_cost += qty * unit_cost
                firm_value += qty * p.price
                products_restocked += 1

            # 4) ç”Ÿäº§æˆæœ¬è®°ä¸ºâ€œç”Ÿäº§å‘ç”Ÿæœˆâ€çš„ä¼ä¸šæ”¯å‡ºï¼ˆç°é‡‘æµå£å¾„ï¼‰
            #    æ³¨ï¼šé”€å”®ä¾§ä¸å†æ‰£â€œæˆæœ¬â€ï¼Œæˆæœ¬å‘ç”Ÿåœ¨ç”Ÿäº§è¡¥è´§æ—¶ã€‚
            if firm_cost > 1e-6:
                self.ledger[owner_id].amount -= firm_cost
                self.record_firm_expense(owner_id, firm_cost)
                self.record_firm_monthly_expense(owner_id, production_month, firm_cost)
                self.firm_monthly_production_cost[owner_id][production_month] += firm_cost

            firm_production[owner_id] = firm_qty
            firm_production_cost[owner_id] = firm_cost
            firm_production_value[owner_id] = firm_value

            total_output += firm_qty
            total_cost_spent += firm_cost

        return {
            "total_output": total_output,
            "products_restocked": products_restocked,
            "firm_production": firm_production,
            "firm_production_cost": firm_production_cost,
            "firm_production_value": firm_production_value,
            "total_production_cost": total_cost_spent,
        }

    async def _decide_research_share_with_llm(
        self, firm, month: int, llm_client=None, model: str = "deepseek-chat"
    ) -> float:
        """
        ä½¿ç”¨å¤§æ¨¡å‹åŠ¨æ€å†³ç­–ä¼ä¸šçš„ç ”å‘æŠ•å…¥æ¯”ä¾‹ Ï

        è¾“å…¥ä¿¡æ¯ï¼š
        - å…¬å¸è¡Œä¸šï¼ˆindustryï¼‰
        - å½“æœˆåˆ©æ¶¦ï¼ˆmonthly_profitï¼‰
        - æ¯›åˆ©ç‡ï¼ˆprofit_marginï¼‰
        - æ”¿ç­–ä¿¡å·ï¼ˆpolicy_encourage_innovationï¼‰
        - é”€é‡æƒ…å†µï¼ˆsales_trendï¼‰

        Returns:
            float: ç ”å‘æŠ•å…¥æ¯”ä¾‹ Ï âˆˆ [0, 1]
        """
        try:
            # 1. æ£€æŸ¥åˆ›æ–°ç­–ç•¥ï¼šæŠ‘åˆ¶åˆ›æ–°ä¹Ÿå…è®¸LLMå†³ç­–ï¼Œä½†é™åˆ¶è¾ƒä½ä¸Šé™
            config = self.firm_innovation_config.get(firm.firm_id)
            if not config:
                self.logger.warning(f"ä¼ä¸š {firm.firm_id} æ²¡æœ‰åˆ›æ–°é…ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼")
                return 0.0
            
            strategy = config.innovation_strategy
            is_suppressed = strategy == "suppressed"
            max_research_share = 0.05 if is_suppressed else 0.3

            # 2. æ”¶é›†ä¼ä¸šä¿¡æ¯
            industry = getattr(firm, 'main_business', 'Unknown')

            # è·å–å½“æœˆè´¢åŠ¡æ•°æ®
            current_financials = self.firm_monthly_financials.get(firm.firm_id, {}).get(month, {})
            monthly_income = current_financials.get("income", 0.0)
            monthly_expenses = current_financials.get("expenses", 0.0)
            monthly_profit = monthly_income - monthly_expenses

            # è·å–æ¯›åˆ©ç‡ï¼ˆä¼˜å…ˆä»é…ç½®ä¸­è·å–ï¼Œå¦åˆ™ä»è¡Œä¸šæ˜ å°„è·å–ï¼‰
            profit_margin = config.profit_margin if config.profit_margin is not None else self.category_profit_margins.get(industry, 25.0)

            # è·å–æ”¿ç­–ä¿¡å·
            policy_signal = strategy == "encouraged"

            # è·å–é”€é‡è¶‹åŠ¿ï¼ˆå¯¹æ¯”ä¸Šæœˆï¼‰
            prev_month = month - 1
            if prev_month > 0:
                prev_financials = self.firm_monthly_financials.get(firm.firm_id, {}).get(prev_month, {})
                prev_income = prev_financials.get("income", 0.0)
                if prev_income > 0:
                    sales_trend = ((monthly_income - prev_income) / prev_income) * 100
                else:
                    sales_trend = 0.0
            else:
                sales_trend = 0.0

            # 3. æ„å»º Prompt
            innovation_status = "suppressed (keep R&D share very small, ideally â‰¤ 0.05)" if is_suppressed else "encouraged/flexible"
            prompt = f"""You are a strategic advisor for a company making R&D investment decisions.

Company Information:
- Industry: {industry}
- Monthly Profit: ${monthly_profit:.2f}
- Profit Margin: {profit_margin:.1f}%
- Policy Encouragement: {'Yes' if policy_signal else 'No'}
- Innovation Status: {innovation_status}
- Sales Trend (vs last month): {sales_trend:+.1f}%
- Current Month: {month}

Task: Decide what proportion (Ï) of the company's workforce should be allocated to R&D instead of production.

Important Constraints:
- Allocating Ï of workers to R&D reduces current production capacity by the same proportion.
- Successful R&D increases future production capacity, but only probabilistically and with uncertain magnitude.
- Excessively high Ï may severely hurt current output and destabilize the company.
- Too low Ï slows innovation and can cause long-term competitiveness loss.
- You must choose Ï such that the trade-off between short-term production loss and potential long-term gains remains reasonable and sustainable for the company.

Considerations:
1. If profit is negative or very low, prioritize production (low Ï).
2. If policy encourages innovation, consider higher Ï.
3. If sales are declining, innovation may help regain market share.
4. If profit margin is high, the company can afford more R&D.
5. Different industries have different innovation needs.
6. If innovation status is "suppressed", keep Ï extremely small (â‰¤ 0.05) but not zero.
7. Always ensure Ï does not compromise baseline operational production.

Output Format:
Provide ONLY a single number between 0.0 and 1.0 representing the R&D workforce proportion.
Example valid outputs: 0.0, 0.05, 0.1, 0.15, 0.2
Do NOT output any explanation, just the number.
"""

            # 4. è°ƒç”¨å¤§æ¨¡å‹ï¼ˆå¦‚æœæä¾›äº†clientï¼‰
            try:
                from openai import AsyncOpenAI
                llm_client = AsyncOpenAI(
                    api_key=os.getenv("DEEPSEEK_API_KEY", ""),
                    base_url=os.getenv("BASE_URL", ""),
                    timeout=60.0  # è®¾ç½®60ç§’è¶…æ—¶
                )
                model = os.getenv("MODEL", "")
                response = await llm_client.chat.completions.create(
                    model=model,
                    messages=[
                        {"role": "system", "content": "You are a strategic business advisor."},
                        {"role": "user", "content": prompt}
                    ]
                )

                # è§£æå“åº”
                content = response.choices[0].message.content.strip()
                research_share = float(content)

                # é™åˆ¶åœ¨åˆç†èŒƒå›´å†…ï¼Œæ ¹æ®ç­–ç•¥è°ƒæ•´ä¸Šé™
                research_share = max(0.0, min(max_research_share, research_share))

                print(f"ğŸ¤– ä¼ä¸š {firm.firm_id} LLMå†³ç­–: ç ”å‘æ¯”ä¾‹={research_share:.1%} "
                            f"(åˆ©æ¶¦=${monthly_profit:.0f}, è¶‹åŠ¿={sales_trend:+.1f}%)")

                return research_share

            except Exception as e:
                self.logger.warning(f"LLMå†³ç­–å¤±è´¥ {firm.firm_id}: {e}, ä½¿ç”¨é»˜è®¤è§„åˆ™")

            # 5. å›é€€æ–¹æ¡ˆï¼šåŸºäºè§„åˆ™çš„å†³ç­–
            print(f"ğŸ” ä¼ä¸š {firm.firm_id} è§„åˆ™å†³ç­–: åˆ©æ¶¦={monthly_profit:.0f}, æ¯›åˆ©ç‡={profit_margin:.1f}%ï¼Œæ”¿ç­–ä¿¡å·={policy_signal}, é”€é‡è¶‹åŠ¿={sales_trend:+.1f}%")
            research_share = self._decide_research_share_rule_based(
                monthly_profit, profit_margin, policy_signal, sales_trend
            )

            self.logger.debug(f"ğŸ“Š ä¼ä¸š {firm.firm_id} è§„åˆ™å†³ç­–: ç ”å‘æ¯”ä¾‹={research_share:.1%}")

            research_share = max(0.0, min(max_research_share, research_share))
            return research_share

        except Exception as e:
            self.logger.error(f"å†³ç­–ç ”å‘æ¯”ä¾‹å¤±è´¥ {firm.firm_id}: {e}")
            return 0.0

    def _decide_research_share_rule_based(
        self, monthly_profit: float, profit_margin: float,
        policy_signal: bool, sales_trend: float
    ) -> float:
        """
        åŸºäºè§„åˆ™çš„ç ”å‘æŠ•å…¥å†³ç­–ï¼ˆLLMçš„å›é€€æ–¹æ¡ˆï¼‰

        Returns:
            float: ç ”å‘æŠ•å…¥æ¯”ä¾‹ Ï âˆˆ [0, 1]
        """
        # åŸºç¡€ç ”å‘æ¯”ä¾‹
        base_share = 0.0

        # 1. åˆ©æ¶¦è¶³å¤Ÿæ‰è€ƒè™‘ç ”å‘
        if monthly_profit <= 0:
            return 0.0

        # 2. æ”¿ç­–é¼“åŠ±åˆ›æ–°
        if policy_signal:
            base_share = 0.1  # 10%åŸºç¡€

        # 3. é”€é‡ä¸‹é™ï¼Œå¢åŠ ç ”å‘æŠ•å…¥æŠ¢å¸‚åœº
        if sales_trend < -5:  # é”€é‡ä¸‹é™è¶…è¿‡5%
            base_share += 0.05

        # 4. é«˜æ¯›åˆ©ç‡è¡Œä¸šå¯ä»¥æ‰¿æ‹…æ›´å¤šç ”å‘
        if profit_margin > 35:
            base_share += 0.03
        elif profit_margin > 25:
            base_share += 0.01

        # 5. åˆ©æ¶¦å¾ˆé«˜ï¼Œå¯ä»¥å¤šæŠ•ç ”å‘
        if monthly_profit > 10000:
            base_share += 0.02

        # é™åˆ¶åœ¨åˆç†èŒƒå›´
        return max(0.0, min(0.25, base_share))

    async def _calculate_effective_labor_force(self, firm, month:int = 0, std_jobs = None) -> Dict[str, float]:
        """
        è®¡ç®—ä¼ä¸šçš„æœ‰æ•ˆåŠ³åŠ¨åŠ›
        æ ¹æ®å‘˜å·¥æŠ€èƒ½ä¸å·¥ä½œè¦æ±‚çš„åŒ¹é…åº¦è®¡ç®—æœ‰æ•ˆåŠ³åŠ¨åŠ›ç³»æ•°
        
        Args:
            firm: ä¼ä¸šå¯¹è±¡
            month: æœˆä»½
        Returns:
            Dict: åŒ…å«æ€»å‘˜å·¥æ•°ã€æœ‰æ•ˆåŠ³åŠ¨åŠ›ã€å¹³å‡åŒ¹é…åˆ†æ•°ç­‰ä¿¡æ¯
        """
        try:
            # è·å–ä¼ä¸šæ‰€æœ‰æ´»è·ƒå‘˜å·¥
            employees = firm.get_all_employees()
            if not employees:
                return {
                    "total_employees": 0,
                    "effective_labor": 0.0,
                    "avg_match_score": 0.0,
                    "skill_details": []
                }
            
            total_match_score = 0.0
            skill_details = []
            
            # è®¡ç®—æ¯ä¸ªå‘˜å·¥çš„æŠ€èƒ½åŒ¹é…åº¦ (é’ˆå¯¹å…¶å…·ä½“èŒä½)
            for employee in employees:
                employee_skills = employee.get("skills", {})
                employee_abilities = employee.get("abilities", {})
                job_title = employee.get("job_title", "")
                job_soc = employee.get("job_soc", "")
                
                # ä¸ºè¯¥å‘˜å·¥è·å–å…¶å…·ä½“èŒä½çš„æŠ€èƒ½è¦æ±‚
                job_requirements = self._get_job_requirements_by_soc(job_soc, std_jobs)
                
                # è®¡ç®—è¯¥å‘˜å·¥ä¸å…¶èŒä½è¦æ±‚çš„åŒ¹é…åˆ†æ•°
                job_skills = job_requirements.get("skills", {})
                job_abilities = job_requirements.get("abilities", {})
                
                
                match_score = self._calculate_skill_match_score(
                    employee_skills,
                    employee_abilities,
                    job_skills,
                    job_abilities
                )
                
                total_match_score += match_score
                skill_details.append({
                    "employee": f"{employee.get('household_id')}_{employee.get('lh_type')}",
                    "job_title": job_title,
                    "job_soc": job_soc,
                    "match_score": match_score,
                    "skills_count": len(employee_skills),
                    "abilities_count": len(employee_abilities)
                })
                
                self.logger.debug(f"å‘˜å·¥ {employee.get('household_id')}_{employee.get('lh_type')} ({job_soc}) æŠ€èƒ½åŒ¹é…åº¦: {match_score:.3f}")
            
            # è®¡ç®—å¹³å‡åŒ¹é…åˆ†æ•°å’Œæœ‰æ•ˆåŠ³åŠ¨åŠ›
            avg_match_score = total_match_score / len(employees)
            effective_labor = total_match_score  # æœ‰æ•ˆåŠ³åŠ¨åŠ› = æ‰€æœ‰å‘˜å·¥åŒ¹é…åˆ†æ•°ä¹‹å’Œ

            # ç ”å‘å æ¯”ï¼šä»…åœ¨å¯ç”¨åˆ›æ–°æ¨¡å—æ—¶æ‰è°ƒç”¨LLMï¼Œé¿å…åœ¨å¸¸è§„æ¨¡å¼ä¸‹å¼•å…¥é¢å¤–ä¸ç¡®å®šæ€§ä¸å¼€é”€
            research_share = 0.0
            if bool(getattr(self, "enable_innovation_module", False)):
                try:
                    research_share = await self._decide_research_share_with_llm(firm, month)
                    self.firm_research_share.append({firm.firm_id: [research_share, month]})
                except Exception as e:
                    self.logger.error(f"è®¡ç®—ä¼ä¸š {firm.firm_id} ç ”å‘æ¯”ä¾‹å¤±è´¥: {e}")
                    research_share = 0.0

            research_share = max(0.0, min(1.0, research_share))
            production_effective_labor = effective_labor * (1 - research_share)
            research_effective_labor = effective_labor - production_effective_labor

            return {
                "total_employees": len(employees),
                "effective_labor": effective_labor,
                "production_effective_labor": production_effective_labor,
                "research_effective_labor": research_effective_labor,
                "research_share": research_share,
                "avg_match_score": avg_match_score,
                "skill_details": skill_details
            }
            
        except Exception as e:
            self.logger.error(f"è®¡ç®—ä¼ä¸š {firm.firm_id} æœ‰æ•ˆåŠ³åŠ¨åŠ›å¤±è´¥: {e}")
            return {
                "total_employees": 0,
                "effective_labor": 0.0,
                "avg_match_score": 0.0,
                "skill_details": []
            }


    # =========================================================================
    # Firm Production & Labor Efficiency
    # =========================================================================
    def estimate_firm_labor_efficiency_no_llm(self, firms: List[Any], std_jobs=None) -> Dict[str, Dict[str, float]]:
        """
        ä¼°ç®—ä¼ä¸šæœ‰æ•ˆåŠ³åŠ¨åŠ›ï¼ˆä¸è°ƒç”¨LLMï¼Œresearch_share=0ï¼‰ã€‚

        ç”¨é€”ï¼š
        - Month1 é¢„å°±ä¸šåç«‹åˆ»åšâ€œGDPâ†’Kâ†’Aâ€çš„CDæ ¡å‡†ï¼Œé¿å…ä¾èµ–æœˆæœ«é”€é‡ä¸LLMå†³ç­–ã€‚
        - ä¹Ÿå¯ç”¨äºè°ƒè¯•/ç¦»çº¿å£å¾„å¯¹é½ã€‚
        """
        results: Dict[str, Dict[str, float]] = {}
        for firm in (firms or []):
            try:
                cid = str(getattr(firm, "firm_id", "") or "")
            except Exception:
                cid = ""
            if not cid:
                continue
            try:
                employees = firm.get_all_employees()
            except Exception:
                employees = []
            if not employees:
                results[cid] = {
                    "total_employees": 0,
                    "effective_labor": 0.0,
                    "production_effective_labor": 0.0,
                    "avg_match_score": 0.0,
                    "research_share": 0.0,
                }
                continue

            total_match_score = 0.0
            for employee in employees:
                try:
                    employee_skills = employee.get("skills", {}) or {}
                    employee_abilities = employee.get("abilities", {}) or {}
                    job_soc = employee.get("job_soc", "") or ""
                except Exception:
                    employee_skills = {}
                    employee_abilities = {}
                    job_soc = ""

                job_requirements = self._get_job_requirements_by_soc(job_soc, std_jobs)
                job_skills = (job_requirements or {}).get("skills", {}) or {}
                job_abilities = (job_requirements or {}).get("abilities", {}) or {}
                try:
                    match_score = float(
                        self._calculate_skill_match_score(
                            employee_skills, employee_abilities, job_skills, job_abilities
                        )
                    )
                except Exception:
                    match_score = 0.0
                total_match_score += max(0.0, match_score)

            n = max(1, len(employees))
            avg_match = total_match_score / float(n)
            effective_labor = float(total_match_score)
            results[cid] = {
                "total_employees": int(len(employees)),
                "effective_labor": float(effective_labor),
                "production_effective_labor": float(effective_labor),
                "avg_match_score": float(avg_match),
                "research_share": 0.0,
            }
        return results
    
    def _get_job_requirements_by_soc(self, soc_code: str, std_jobs = None) -> Dict:
        """
        æ ¹æ®å•ä¸ªSOC Codeè·å–å…·ä½“èŒä½çš„æŠ€èƒ½è¦æ±‚
        
        Args:
            soc_code: O*NET-SOC Code
            std_jobs: æ ‡å‡†å·¥ä½œæ•°æ®
            
        Returns:
            Dict: åŒ…å«skillså’Œabilitiesè¦æ±‚çš„å­—å…¸
        """
        try:
            if std_jobs is None or std_jobs.empty or not soc_code:
                return self._get_default_job_requirements()
            
            # åœ¨std_jobsä¸­æŸ¥æ‰¾åŒ¹é…çš„å·¥ä½œ
            matching_jobs = std_jobs[std_jobs['O*NET-SOC Code'] == soc_code]
            if not matching_jobs.empty:
                job_info = matching_jobs.iloc[0]
                job_skills = job_info.get('skills', {})
                job_abilities = job_info.get('abilities', {})
                
                self.logger.debug(f"æ‰¾åˆ°SOC {soc_code}çš„å·¥ä½œè¦æ±‚: {job_info.get('Title', 'Unknown')}")
                
                return {
                    "skills": job_skills if isinstance(job_skills, dict) else {},
                    "abilities": job_abilities if isinstance(job_abilities, dict) else {}
                }
            else:
                self.logger.debug(f"æœªæ‰¾åˆ°SOC {soc_code}çš„å·¥ä½œè¦æ±‚ï¼Œä½¿ç”¨é»˜è®¤è¦æ±‚")
                
        except Exception as e:
            self.logger.error(f"è·å–SOC {soc_code}å·¥ä½œè¦æ±‚å¤±è´¥: {e}")


    def _calculate_skill_match_score(self, worker_skills: Dict, worker_abilities: Dict,
                                   job_skills: Dict, job_abilities: Dict) -> float:
        """
        è®¡ç®—å·¥äººæŠ€èƒ½ä¸å·¥ä½œè¦æ±‚çš„åŒ¹é…åˆ†æ•°
        è¿”å› 0-1 ä¹‹é—´çš„åˆ†æ•°ï¼Œè¡¨ç¤ºåŒ¹é…åº¦
        """
        total_score = 0
        total_weight = 0
        
        # è®¡ç®—æŠ€èƒ½åŒ¹é…åˆ†æ•°
        for skill_name, skill_req in job_skills.items():
            if skill_name in worker_skills:
                required_mean = skill_req.get('mean', 50)
                required_std = skill_req.get('std', 10)
                importance = skill_req.get('importance', 1.0)

                worker_value = worker_skills[skill_name]

                # è®¡ç®—åŒ¹é…åº¦ï¼Œé˜²æ­¢é™¤é›¶é”™è¯¯
                if required_std > 0 and required_mean > 0:
                    # ä½¿ç”¨æ ‡å‡†åŒ–è·ç¦»è®¡ç®—åŒ¹é…åº¦ï¼ˆç±»ä¼¼äºjobmarket.pyçš„ç®—æ³•ï¼‰
                    distance = abs(worker_value - required_mean) / required_std
                    skill_score = max(0, 1 - distance / 3)  # 3ä¸ªæ ‡å‡†å·®å¤–ä¸º0åˆ†
                else:
                    # å¦‚æœstdæˆ–meanä¸º0ï¼Œä½¿ç”¨ç®€å•æ¯”è¾ƒ
                    if required_mean > 0:
                        skill_score = min(worker_value / required_mean, 1.0)
                    else:
                        # å¦‚æœè¦æ±‚å€¼ä¸º0ï¼Œä½¿ç”¨é»˜è®¤åŒ¹é…åˆ†æ•°
                        skill_score = 0.5

                # å¦‚æœimportanceä¸º0ï¼Œè·³è¿‡è¿™ä¸ªæŠ€èƒ½
                if importance > 0:
                    total_score += skill_score * importance
                    total_weight += importance
            else:
                # ç¼ºå°‘æŠ€èƒ½çš„æƒ©ç½š
                importance = skill_req.get('importance', 1.0)
                if importance > 0:
                    total_score += 0.3 * importance  # ç»™äºˆ30%çš„åŸºç¡€åˆ†
                    total_weight += importance
        
        # è®¡ç®—èƒ½åŠ›åŒ¹é…åˆ†æ•°
        for ability_name, ability_req in job_abilities.items():
            if ability_name in worker_abilities:
                required_mean = ability_req.get('mean', 50)
                required_std = ability_req.get('std', 10)
                importance = ability_req.get('importance', 1.0)

                worker_value = worker_abilities[ability_name]

                # è®¡ç®—åŒ¹é…åº¦ï¼Œé˜²æ­¢é™¤é›¶é”™è¯¯
                if required_std > 0 and required_mean > 0:
                    # ä½¿ç”¨æ ‡å‡†åŒ–è·ç¦»è®¡ç®—åŒ¹é…åº¦
                    distance = abs(worker_value - required_mean) / required_std
                    ability_score = max(0, 1 - distance / 3)  # 3ä¸ªæ ‡å‡†å·®å¤–ä¸º0åˆ†
                else:
                    # å¦‚æœstdæˆ–meanä¸º0ï¼Œä½¿ç”¨ç®€å•æ¯”è¾ƒ
                    if required_mean > 0:
                        ability_score = min(worker_value / required_mean, 1.0)
                    else:
                        # å¦‚æœè¦æ±‚å€¼ä¸º0ï¼Œä½¿ç”¨é»˜è®¤åŒ¹é…åˆ†æ•°
                        ability_score = 0.5

                # å¦‚æœimportanceä¸º0ï¼Œè·³è¿‡è¿™ä¸ªèƒ½åŠ›
                if importance > 0:
                    total_score += ability_score * importance
                    total_weight += importance
            else:
                # ç¼ºå°‘èƒ½åŠ›çš„æƒ©ç½š
                importance = ability_req.get('importance', 1.0)
                if importance > 0:
                    total_score += 0.3 * importance  # ç»™äºˆ30%çš„åŸºç¡€åˆ†
                    total_weight += importance
        
        # è¿”å›åŠ æƒå¹³å‡åˆ†æ•°
        return total_score / total_weight if total_weight > 0 else 0.5

    async def _execute_labor_based_production(
        self, month: int, sales_data: Dict, labor_market, product_market=None, firms: List = None, std_jobs = None, production_config: Dict = None, innovation_config: Dict = None
    ) -> Dict[str, Any]:
        """
        ä¸ºæœ‰å·¥äººçš„å…¬å¸æ‰§è¡ŒåŸºäºåŠ³åŠ¨åŠ›çš„é¢å¤–ç”Ÿäº§
        è€ƒè™‘å‘˜å·¥æŠ€èƒ½åŒ¹é…åº¦è®¡ç®—æœ‰æ•ˆåŠ³åŠ¨åŠ›
        """
        total_output = 0.0
        companies_with_workers = 0
        firm_labor_efficiency = {}  # è®°å½•æ¯å®¶ä¼ä¸šçš„åŠ³åŠ¨æ•ˆç‡
        firm_labor_production = {}  # è®°å½•æ¯å®¶ä¼ä¸šçš„åŠ³åŠ¨åŠ›ç”Ÿäº§é‡
        firm_labor_production_value = {}  # è®°å½•æ¯å®¶ä¼ä¸šåŠ³åŠ¨åŠ›ç”Ÿäº§çš„æ€»ä»·å€¼ï¼ˆæŒ‰å”®ä»·ä¼°å€¼ï¼‰

        firm_research_labor = {}
        total_research_effective_labor = 0.0
        policy_signal = None if innovation_config is None else innovation_config.get("policy_signal", None)
        
        # åˆ›æ–°æ¨¡å—ï¼šè®°å½•æ¯å®¶ä¼ä¸šåˆ›æ–°åˆ°è¾¾ç‡å’Œåˆ°è¾¾æ¬¡æ•°
        firm_innovation_arrival_rate = {}  # Î›_t = Î» * (research_effective_labor)^beta
        firm_innovation_arrivals = {}  # æ³Šæ¾é‡‡æ ·å¾—åˆ°çš„åˆ›æ–°åˆ°è¾¾æ¬¡æ•°
        try:
            # è®¡ç®—æ¯å®¶ä¼ä¸šçš„æœ‰æ•ˆåŠ³åŠ¨åŠ›
            if firms:
                for firm in firms:
                    if firm.get_employees() > 0:  # åªå¤„ç†æœ‰å‘˜å·¥çš„ä¼ä¸š
                        try:
                            effective_labor = await self._calculate_effective_labor_force(firm, month, std_jobs)
                            firm_labor_efficiency[firm.firm_id] = effective_labor
                            # jiaju_add_4 start è®¡ç®—åˆ›æ–°åˆ°è¾¾ç‡å’Œæ¬¡æ•° æ ¸å¿ƒä»£ç 
                            if self.enable_innovation_module:
                                if policy_signal is not None:
                                    effective_labor['policy_signal'] = policy_signal
                                research_eff = effective_labor.get('research_effective_labor', 0.0)
                                firm_research_labor[firm.firm_id] = research_eff
                                total_research_effective_labor += research_eff
                                
                                # è®¡ç®—åˆ›æ–°åˆ°è¾¾ç‡ Î›_t = Î» * (research_effective_labor)^beta
                                if innovation_config and innovation_config.get('enable_innovation_module', False):
                                    innovation_lambda = innovation_config.get('innovation_lambda', 0.05)
                                    innovation_beta = innovation_config.get('innovation_concavity_beta', 0.6)
                                    
                                    # Î›_t = Î» * (effective_research_labor)^beta
                                    if research_eff > 0:
                                        innovation_arrival_rate = innovation_lambda * (research_eff ** innovation_beta)
                                    else:
                                        innovation_arrival_rate = 0.0
                                    
                                    # é™åˆ¶åˆ°è¾¾ç‡åœ¨åˆç†èŒƒå›´å†…ï¼ˆé¿å…è¿‡å¤§ï¼‰
                                    innovation_arrival_rate = min(innovation_arrival_rate, 10.0)  # æœ€å¤§æ¯æœˆ10æ¬¡
                                    
                                    firm_innovation_arrival_rate[firm.firm_id] = innovation_arrival_rate
                                    
                                    # æ³Šæ¾é‡‡æ ·ï¼šä»æ³Šæ¾åˆ†å¸ƒä¸­é‡‡æ ·åˆ›æ–°åˆ°è¾¾æ¬¡æ•°
                                    # æ³Šæ¾åˆ†å¸ƒçš„å‚æ•°ä¸º Î›_tï¼Œé‡‡æ ·ç»“æœè¡¨ç¤ºæœ¬æœˆåˆ›æ–°å‘ç”Ÿçš„æ¬¡æ•°ï¼ˆéè´Ÿæ•´æ•°ï¼‰
                                    # æ³¨ï¼šP(è‡³å°‘å‘ç”Ÿ1æ¬¡) = 1 - exp(-Î›_t)ï¼Œä½†è¿™é‡Œæˆ‘ä»¬ç›´æ¥é‡‡æ ·æ¬¡æ•°ï¼ˆinnovation_arrivalsä¸ºéè´Ÿæ•´æ•°ï¼‰
                                    if innovation_arrival_rate > 0:
                                        innovation_arrivals = np.random.poisson(innovation_arrival_rate)
                                    else:
                                        innovation_arrivals = 0
                                    
                                    firm_innovation_arrivals[firm.firm_id] = innovation_arrivals
                                    
                                    print(
                                        f"ğŸ”¬ ä¼ä¸š {firm.firm_id} åˆ›æ–°: ç ”å‘æœ‰æ•ˆåŠ³åŠ¨åŠ›={research_eff:.2f}, "
                                        f"åˆ°è¾¾ç‡Î›_t={innovation_arrival_rate:.4f}, æœ¬æœˆåˆ°è¾¾æ¬¡æ•°={innovation_arrivals}"
                                    )
                                # jiaju_add_4 end
                                print(f"ğŸ­ ä¼ä¸š {firm.firm_id} æœ‰æ•ˆåŠ³åŠ¨åŠ›: {effective_labor['effective_labor']:.2f} (å‘˜å·¥æ•°: {firm.get_employees()})")
                        except Exception as e:
                            self.logger.error(f"è®¡ç®—ä¼ä¸š {firm.firm_id} åŠ³åŠ¨æ•ˆç‡å¤±è´¥: {e}")
                            firm_labor_efficiency[firm.firm_id] = {"total_employees": 0, "effective_labor": 0.0, "avg_match_score": 0.0}
                            # åˆå§‹åŒ–åˆ›æ–°åˆ°è¾¾æ¬¡æ•°ä¸º0ï¼Œé¿å…åç»­è®¿é—®æ—¶å‡ºç°KeyError
                            firm_innovation_arrivals[firm.firm_id] = 0
            
            # è·å–æ‰€æœ‰æœ‰å·¥äººçš„å…¬å¸
            companies_with_employees = await self._get_companies_with_employees(labor_market)
            
            for firm_id, employee_count in companies_with_employees.items():
                if employee_count == 0:
                    continue
                    
                companies_with_workers += 1
                # jiaju_add_5 start è·å–ä¿¡æ¯
                # è·å–è¯¥ä¼ä¸šçš„æœ‰æ•ˆåŠ³åŠ¨åŠ›ä¿¡æ¯
                labor_info = firm_labor_efficiency.get(
                    firm_id, {"effective_labor": employee_count, "avg_match_score": 1.0}
                )
                production_labor = labor_info.get("production_effective_labor", labor_info.get("effective_labor", employee_count))
                research_share = labor_info.get("research_share", 0.0)

                # è·å–è¯¥ä¼ä¸šçš„åˆ›æ–°åˆ°è¾¾æ¬¡æ•°ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™é»˜è®¤ä¸º0
                innovation_arrivals = firm_innovation_arrivals.get(firm_id, 0)

                # å¦‚æœæœ‰åˆ›æ–°åˆ°è¾¾ï¼Œå…ˆå¤„ç†åˆ›æ–°åˆ°è¾¾ï¼ˆæ›´æ–° labor_productivity_factorï¼‰ï¼Œä»¥ä¾¿å½±å“æœ¬æœˆç”Ÿäº§
                if innovation_arrivals > 0 and innovation_config and innovation_config.get('enable_innovation_module', False):
                    await self.handle_innovation_arrival(firm_id, month, innovation_arrivals, innovation_config, product_market)
                
                # è®¡ç®—è¯¥å…¬å¸çš„åŠ³åŠ¨åŠ›äº§å‡º (ä½¿ç”¨æœ‰æ•ˆåŠ³åŠ¨åŠ›è€Œä¸æ˜¯å‘˜å·¥æ•°é‡)
                # æ³¨æ„ï¼šå¦‚æœæœ‰åˆ›æ–°åˆ°è¾¾ï¼Œè¿™é‡Œä¼šä½¿ç”¨æ›´æ–°åçš„ labor_productivity_factor
                company_output, company_output_value = await self._calculate_company_labor_production(
                    firm_id, production_labor * (1 - research_share), sales_data, production_config
                )

                total_output += company_output
                firm_labor_production[firm_id] = company_output  # è®°å½•è¯¥ä¼ä¸šçš„åŠ³åŠ¨åŠ›ç”Ÿäº§é‡

                # ç²¾ç¡®ä»·å€¼ï¼šç”± _calculate_company_labor_production æŒ‰â€œäº§å“ç»´åº¦å¢é‡Ã—å”®ä»·â€ç´¯åŠ å¾—åˆ°
                firm_labor_production_value[firm_id] = float(company_output_value)
                # åŒæ­¥åˆ°æœˆåº¦ç»Ÿè®¡å®¹å™¨ï¼ˆä¾›å¤–éƒ¨å¯¼å‡º/æ±‡æ€»ï¼‰
                self.firm_monthly_labor_production_value[firm_id][month] += float(company_output_value)

                self.logger.debug(
                    f"åŠ³åŠ¨åŠ›ç”Ÿäº§: å…¬å¸ {firm_id} å‘˜å·¥ {employee_count} äººï¼Œäº§å‡º {company_output:.2f} | ç ”å‘ä»½é¢ {research_share:.2f} | åˆ›æ–°åˆ°è¾¾ {innovation_arrivals}"
                )

        except Exception as e:
            self.logger.warning(f"åŠ³åŠ¨åŠ›ç”Ÿäº§è®¡ç®—å¤±è´¥: {e}")
            import traceback
            traceback.print_exc()
        
        return {
            "total_output": total_output,
            "companies_count": companies_with_workers,
            "firm_labor_efficiency": firm_labor_efficiency,
            "firm_labor_production": firm_labor_production,  # æ–°å¢ï¼šæ¯ä¸ªä¼ä¸šçš„åŠ³åŠ¨åŠ›ç”Ÿäº§é‡
            "firm_labor_production_value": firm_labor_production_value,
            "total_labor_production_value": sum(firm_labor_production_value.values()) if firm_labor_production_value else 0.0,
            "firm_research_labor": firm_research_labor,
            "total_research_effective_labor": total_research_effective_labor,
            "firm_innovation_arrival_rate": firm_innovation_arrival_rate,  # åˆ›æ–°åˆ°è¾¾ç‡ Î›_t
            "firm_innovation_arrivals": firm_innovation_arrivals  # æ³Šæ¾é‡‡æ ·çš„åˆ›æ–°åˆ°è¾¾æ¬¡æ•°
        }
        # jiaju_add_5 end

    async def handle_innovation_arrival(self, firm_id: str, month: int, innovation_arrivals: int, innovation_config: Dict = None, product_market=None):
        """
        å¤„ç†åˆ›æ–°åˆ°è¾¾ éšæœºé€‰æ‹©ä¸‰ç§æ–¹å¼
        1. é™ä»·+æé«˜äº§é‡ï¼ˆåŸå…ˆçš„update_prices_innovation_arrivalæ–¹æ³•ï¼‰
        2. æ¶¨ä»·+æå‡å•†å“å±æ€§
        3. æé«˜æ¯›åˆ©ç‡
        
        Args:
            firm_id: å…¬å¸ID
            month: æœˆä»½
            innovation_arrivals: åˆ›æ–°åˆ°è¾¾æ¬¡æ•°
            innovation_config: åˆ›æ–°é…ç½®
            product_market: å•†å“å¸‚åœºå¯¹è±¡ï¼ˆå¯é€‰ï¼Œç”¨äºåŒæ­¥æ›´æ–°ï¼‰
        """
        # é˜²å¾¡ï¼šæœªå¼€å¯åˆ›æ–°æ¨¡å—æ—¶ï¼Œç›´æ¥å¿½ç•¥
        if (not self.enable_innovation_module) or (not isinstance(innovation_config, dict)) or (not innovation_config.get("enable_innovation_module", False)):
            return

        if innovation_arrivals > 0:
            for i in range(innovation_arrivals):
                innovation_type = random.choice([1, 2, 3])
                if innovation_type == 1:
                    await self.update_prices_innovation_arrival(firm_id, innovation_config.get('innovation_gamma', 1.2), month)
                elif innovation_type == 2:
                    await self.update_product_attributes_innovation_arrival(firm_id, innovation_config.get('innovation_gamma', 1.2), month)
                elif innovation_type == 3:
                    await self.update_profit_margin_innovation_arrival(firm_id, innovation_config.get('innovation_gamma', 1.2), month)
            
            # åˆ›æ–°åˆ°è¾¾åï¼ŒåŒæ­¥æ›´æ–°åˆ°å•†å“å¸‚åœº
            if product_market is not None:
                try:
                    # æ”¶é›†è¯¥å…¬å¸æ‰€æœ‰æ›´æ–°çš„å•†å“
                    if firm_id in self.products:
                        company_products = [p for p in self.products[firm_id] if p.amount > 0]
                        if company_products:
                            await product_market.update_products_from_economic_center.remote(company_products)
                            self.logger.info(f"å·²åŒæ­¥å…¬å¸ {firm_id} çš„åˆ›æ–°æ›´æ–°åˆ°å•†å“å¸‚åœºï¼ˆ{len(company_products)} ä¸ªå•†å“ï¼‰")
                except Exception as e:
                    self.logger.warning(f"åŒæ­¥åˆ›æ–°æ›´æ–°åˆ°å•†å“å¸‚åœºå¤±è´¥: {e}")

    async def update_prices_innovation_arrival(self, firm_id: str, gamma: float = 1.2, month: int = 0):
        """
        æ›´æ–°å…¬å¸ä»·æ ¼å’Œåˆ›æ–°åˆ°è¾¾æ¬¡æ•°
        """
        if firm_id not in self.products or not self.products[firm_id]:
            return
        price_change = np.sqrt(gamma)
        for product in self.products[firm_id]:
            product.price = product.price * (1/price_change)
        print(f"ğŸ”¬ å…¬å¸ {firm_id} {month}æœˆä»·æ ¼å˜åŒ– {price_change}")

        if firm_id not in self.firm_innovation_config:
            self.logger.warning(f"å…¬å¸ {firm_id} æ²¡æœ‰åˆ›æ–°é…ç½®ï¼Œæ— æ³•æ›´æ–°åŠ³åŠ¨åŠ›å› ç´ ")
            return
        
        config = self.firm_innovation_config[firm_id]
        old_labor_production = config.labor_productivity_factor
        new_labor_production = old_labor_production * gamma
        print(f"ğŸ”¬ å…¬å¸ {firm_id} {month}æœˆåŠ³åŠ¨åŠ›å› ç´ å˜åŒ– {old_labor_production} -> {new_labor_production}")
        
        # ç›´æ¥æ›´æ–°å­—å…¸ä¸­å­˜å‚¨çš„å¯¹è±¡å±æ€§ï¼Œç¡®ä¿ä¿®æ”¹ç«‹å³ç”Ÿæ•ˆ
        self.firm_innovation_config[firm_id].labor_productivity_factor = new_labor_production

        self.add_innovation_event(
            firm_id=firm_id,
            month=month,
            innovation_type='price',
            price_change=price_change
        )
        self.add_innovation_event(
            firm_id=firm_id,
            month=month,
            innovation_type='labor_productivity_factor',
            old_value=old_labor_production,
            new_value=new_labor_production
        )

    async def update_product_attributes_innovation_arrival(self, firm_id: str, gamma: float = 1.2, month: int = 0):
        """
        æ›´æ–°å…¬å¸å•†å“å±æ€§
        """
        if firm_id not in self.products or not self.products[firm_id]:
            return
        
        def _scale_numeric_fields(payload: Any, multiplier: float):
            """
            é€’å½’æ”¾å¤§å­—å…¸/åˆ—è¡¨ä¸­çš„æ•°å€¼å­—æ®µï¼Œä¿æŒå…¶ä½™ç»“æ„ä¸å˜ã€‚
            """
            if isinstance(payload, dict):
                return {k: _scale_numeric_fields(v, multiplier) for k, v in payload.items()}
            if isinstance(payload, list):
                return [_scale_numeric_fields(v, multiplier) for v in payload]
            if isinstance(payload, (int, float)):
                return payload * multiplier
            return payload

        updated_products = 0
        for product in self.products[firm_id]:
            before_snapshot = {
                "attributes": copy.deepcopy(product.attributes) if isinstance(product.attributes, (dict, list)) else product.attributes,
                "nutrition": copy.deepcopy(product.nutrition_supply) if isinstance(product.nutrition_supply, (dict, list)) else product.nutrition_supply,
                "satisfaction": copy.deepcopy(product.satisfaction_attributes) if isinstance(product.satisfaction_attributes, (dict, list)) else product.satisfaction_attributes,
            }

            if product.attributes:
                product.attributes = _scale_numeric_fields(product.attributes, gamma)
            if product.nutrition_supply:
                product.nutrition_supply = _scale_numeric_fields(product.nutrition_supply, gamma)
            if product.satisfaction_attributes:
                product.satisfaction_attributes = _scale_numeric_fields(product.satisfaction_attributes, gamma)

            # å¦‚æœæœ‰ä»»ä½•å­—æ®µå‘ç”Ÿå˜åŒ–ï¼Œåˆ™è®°å½•
            if before_snapshot["attributes"] != product.attributes or \
               before_snapshot["nutrition"] != product.nutrition_supply or \
               before_snapshot["satisfaction"] != product.satisfaction_attributes:
                updated_products += 1

        if updated_products > 0:
            print(f"ğŸ”¬ å…¬å¸ {firm_id} {month}æœˆå•†å“å±æ€§æå‡: æ”¾å¤§ç³»æ•°={gamma}, å—å½±å“å•†å“={updated_products} ä»¶")
            self.add_innovation_event(
                firm_id=firm_id,
                month=month,
                innovation_type='attribute',
                attribute_change=gamma
            )

    async def update_profit_margin_innovation_arrival(self, firm_id: str, gamma: float = 1.2, month: int = 0):
        """
        æ›´æ–°å…¬å¸æ¯›åˆ©ç‡
        """
        if firm_id not in self.firm_innovation_config:
            self.logger.warning(f"å…¬å¸ {firm_id} æ²¡æœ‰åˆ›æ–°é…ç½®ï¼Œæ— æ³•æ›´æ–°æ¯›åˆ©ç‡")
            return
        
        config = self.firm_innovation_config[firm_id]
        if config.profit_margin is None:
            self.logger.warning(f"å…¬å¸ {firm_id} æ¯›åˆ©ç‡ä¸ºNoneï¼Œæ— æ³•æ›´æ–°")
            return
        
        old_profit_margin = config.profit_margin
        new_profit_margin = old_profit_margin * gamma
        print(f"ğŸ”¬ å…¬å¸ {firm_id} {month}æœˆæ¯›åˆ©ç‡å˜åŒ– {old_profit_margin} -> {new_profit_margin}")
        
        # ç›´æ¥æ›´æ–°å­—å…¸ä¸­å­˜å‚¨çš„å¯¹è±¡å±æ€§ï¼Œç¡®ä¿ä¿®æ”¹ç«‹å³ç”Ÿæ•ˆ
        self.firm_innovation_config[firm_id].profit_margin = new_profit_margin

        self.add_innovation_event(
            firm_id=firm_id,
            month=month,
            innovation_type='profit_margin',
            old_value=old_profit_margin,
            new_value=new_profit_margin
        )

    async def _get_companies_with_employees(self, labor_market) -> Dict[str, int]:
        """
        è·å–æ‰€æœ‰æœ‰å‘˜å·¥çš„å…¬å¸åŠå…¶å‘˜å·¥æ•°é‡
        """
        companies_employees = {}
        
        try:
            # ä»åŠ³åŠ¨åŠ›å¸‚åœºè·å–æ‰€æœ‰åŒ¹é…çš„å·¥ä½œ
            matched_jobs = await labor_market.query_matched_jobs.remote()
            
            # ç»Ÿè®¡æ¯ä¸ªå…¬å¸çš„å‘˜å·¥æ•°é‡
            for job in matched_jobs:
                firm_id = job.firm_id
                companies_employees[firm_id] = companies_employees.get(firm_id, 0) + 1
        
        except Exception as e:
            self.logger.warning(f"è·å–å…¬å¸å‘˜å·¥æ•°æ®å¤±è´¥: {e}")
        
        return companies_employees

    async def _calculate_company_labor_production(
        self, firm_id: str, employee_count: int, sales_data: Dict, production_config: Dict = None
    ) -> Tuple[float, float]:
        """
        è®¡ç®—å•ä¸ªå…¬å¸åŸºäºåŠ³åŠ¨åŠ›çš„äº§å‡º
        ä½¿ç”¨ç®€åŒ–çš„æŸ¯å¸ƒ-é“æ ¼æ‹‰æ–¯ç”Ÿäº§å‡½æ•°ï¼ˆä»·å€¼å£å¾„ï¼‰: V = A Ã— L^Î±
        - V: åŠ³åŠ¨åŠ›ç”Ÿäº§çš„â€œäº§å‡ºæ€»ä»·å€¼â€ï¼ˆæŒ‰å”®ä»·ä¼°å€¼ï¼Œä¸å«ç¨ï¼‰ï¼Œç”¨äºä¸å·¥èµ„æ”¯å‡ºå¯¹é½æ ¡å‡† A
        - å°† V æŒ‰å•†å“ä¼˜å…ˆçº§åˆ†é…åˆ°å…·ä½“SKUï¼Œå†æŒ‰å½“å‰å”®ä»·æ¢ç®—ä¸ºä»¶æ•°å¹¶å¢åŠ åº“å­˜
        
        Args:
            employee_count: æœ‰æ•ˆåŠ³åŠ¨åŠ›æ•°é‡
            production_config: ç”Ÿäº§é…ç½®å‚æ•°
        """
        if firm_id not in self.products or not self.products[firm_id]:
            return 0.0, 0.0
        
        labor_elasticity = production_config.get('labor_elasticity', 0.7) if production_config else 0.7
        # è¯»å– Aï¼ˆä¼˜å…ˆ company->industry->firm_config->globalï¼‰
        firm_productivity_factor = None
        if isinstance(production_config, dict):
            company_factors = production_config.get("company_labor_productivity_factors") or {}
            if isinstance(company_factors, dict):
                try:
                    v = float(company_factors.get(firm_id, 0.0) or 0.0)
                    if v > 0:
                        firm_productivity_factor = v
                except Exception:
                    firm_productivity_factor = None

            if firm_productivity_factor is None:
                industry_factors = production_config.get("industry_labor_productivity_factors") or {}
                company_industries = production_config.get("company_industries") or {}
                industry = None
                if isinstance(company_industries, dict):
                    industry = company_industries.get(firm_id)
                if not industry:
                    # å›é€€ï¼šç”¨ä¼ä¸šå•†å“çš„ä¸»åˆ†ç±»çŒœæµ‹è¡Œä¸š
                    try:
                        industry = getattr(self.products[firm_id][0], "classification", None)
                    except Exception:
                        industry = None
                if isinstance(industry_factors, dict) and industry:
                    try:
                        v = float(industry_factors.get(industry, 0.0) or 0.0)
                        if v > 0:
                            firm_productivity_factor = v
                    except Exception:
                        firm_productivity_factor = None

        if firm_productivity_factor is None:
            config = self.firm_innovation_config.get(firm_id)
            try:
                v = float(getattr(config, "labor_productivity_factor", 0.0) or 0.0) if config else 0.0
                if v > 0:
                    firm_productivity_factor = v
            except Exception:
                firm_productivity_factor = None

        if firm_productivity_factor is None:
            firm_productivity_factor = production_config.get('labor_productivity_factor', 30.0) if production_config else 30.0

        # è®¡ç®—æ€»çš„åŠ³åŠ¨åŠ›äº§å‡ºæ€»ä»·å€¼: V = A Ã— L^Î±
        try:
            effective_labor = float(employee_count or 0.0)
        except Exception:
            effective_labor = 0.0
        effective_labor = max(0.0, effective_labor)
        total_labor_output_value = float(firm_productivity_factor) * (effective_labor ** float(labor_elasticity))
        
        # æ ¹æ®é”€é‡æƒ…å†µåˆ†é…äº§å‡ºåˆ°ä¸åŒäº§å“
        # ğŸ”§ ä¼˜å…ˆæŒ‰ç…§"å®¶åº­è´­ä¹°è¿‡çš„å•†å“"çš„é”€é‡å æ¯”è¿›è¡Œåˆ†é…ï¼›
        #    è‹¥å½“æœˆæ— ä»»ä½•å®¶åº­è´­ä¹°è®°å½•ï¼Œåˆ™å›é€€åˆ°åŸæœ‰çš„é”€é‡/åº“å­˜ä¼˜å…ˆçº§è§„åˆ™ã€‚
        company_products = self.products[firm_id]
        product_priorities = {}
        household_sum = 0.0
        
        # è®¡ç®—æ¯ä¸ªäº§å“çš„ä¼˜å…ˆçº§ï¼ˆä»…å¯¹å¯å®šä»·å•†å“åˆ†é…ï¼‰
        for product in company_products:
            price = float(getattr(product, "price", 0.0) or 0.0)
            if price <= 0:
                continue
            product_id = product.product_id
            sales_key = (product_id, firm_id)
            
            # è®¡ç®—ä¼˜å…ˆçº§åˆ†æ•°ï¼ˆåŸºäºé”€é‡å’Œåº“å­˜æ°´å¹³ï¼‰
            # ä½¿ç”¨ (product_id, firm_id) ä½œä¸ºkeyæŸ¥æ‰¾é”€é‡æ•°æ®
            if sales_key in sales_data:
                # æœ‰é”€å”®è®°å½•ï¼šåŸºäºé”€é‡è®¡ç®—ä¼˜å…ˆçº§
                sales_info = sales_data[sales_key]
                quantity_sold = sales_info.get("quantity_sold", 0)
                demand_level = sales_info.get("demand_level", "normal")
                
                # è®¡ç®—ä¼˜å…ˆçº§åˆ†æ•°
                priority_score = quantity_sold
                if demand_level == "high":
                    priority_score *= 2.0
                elif demand_level == "low":
                    priority_score *= 0.5
                
                product_priorities[product_id] = priority_score
                hh_qty = float(sales_info.get("household_quantity", 0.0) or 0.0)
                household_sum += hh_qty
            else:
                # ğŸ”§ ä¿®æ”¹ï¼šæ— é”€å”®è®°å½•çš„å•†å“ä¹Ÿå‚ä¸åŠ³åŠ¨åŠ›ç”Ÿäº§ï¼ˆå¯èƒ½æ˜¯åº“å­˜ä¸º0ï¼‰
                # åŸºäºåº“å­˜æ°´å¹³è®¡ç®—ä¼˜å…ˆçº§
                if product.amount == 0:
                    # åº“å­˜ä¸º0çš„å•†å“ï¼Œç»™äºˆä¸­ç­‰ä¼˜å…ˆçº§ï¼ˆç›¸å½“äºé”€é‡10ï¼‰
                    priority_score = 10.0
                elif product.amount < 50:
                    # ä½åº“å­˜å•†å“ï¼Œç»™äºˆè¾ƒä½ä¼˜å…ˆçº§ï¼ˆç›¸å½“äºé”€é‡5ï¼‰
                    priority_score = 5.0
                else:
                    # é«˜åº“å­˜å•†å“ï¼Œç»™äºˆæœ€ä½ä¼˜å…ˆçº§ï¼ˆç›¸å½“äºé”€é‡1ï¼‰
                    priority_score = 1.0
                
                product_priorities[product_id] = priority_score
                self.logger.debug(f"åŠ³åŠ¨åŠ›ç”Ÿäº§: {product.name} (æ— é”€å”®è®°å½•, åº“å­˜{product.amount:.1f}, ä¼˜å…ˆçº§{priority_score})")
        
        # è‹¥æœ‰å®¶åº­è´­ä¹°è®°å½•ï¼Œåˆ™æŒ‰å®¶åº­é”€é‡å æ¯”åˆ†é…ï¼›
        # å¦åˆ™å›é€€åˆ°åŸºäºé”€é‡/åº“å­˜çš„ä¼˜å…ˆçº§é€»è¾‘ã€‚
        if household_sum == 0.0:
            product_priorities = {}
            for product in company_products:
                price = float(getattr(product, "price", 0.0) or 0.0)
                if price <= 0:
                    continue
                product_id = product.product_id
                sales_key = (product_id, firm_id)
                if sales_key in sales_data:
                    sales_info = sales_data[sales_key]
                    quantity_sold = sales_info.get("quantity_sold", 0)
                    demand_level = sales_info.get("demand_level", "normal")
                    priority_score = quantity_sold
                    if demand_level == "high":
                        priority_score *= 2.0
                    elif demand_level == "low":
                        priority_score *= 0.5
                    product_priorities[product_id] = priority_score
                else:
                    if product.amount == 0:
                        priority_score = 10.0
                    elif product.amount < 50:
                        priority_score = 5.0
                    else:
                        priority_score = 1.0
                    product_priorities[product_id] = priority_score
                    self.logger.debug(f"åŠ³åŠ¨åŠ›ç”Ÿäº§: {product.name} (æ— é”€å”®è®°å½•, åº“å­˜{product.amount:.1f}, ä¼˜å…ˆçº§{priority_score})")
        
        # æŒ‰ä¼˜å…ˆçº§åˆ†é…äº§å‡º
        total_priority = sum(product_priorities.values())
        actual_output = 0.0
        actual_output_value = 0.0
        
        if total_priority > 0:
            for product in company_products:
                product_id = product.product_id
                
                # åªå¤„ç†æœ‰ä¼˜å…ˆçº§çš„äº§å“ï¼ˆç°åœ¨æ‰€æœ‰äº§å“éƒ½æœ‰ä¼˜å…ˆçº§ï¼‰
                if product_id not in product_priorities:
                    continue
                
                priority = product_priorities[product_id]
                
                price = float(getattr(product, "price", 0.0) or 0.0)
                if price <= 0:
                    continue

                # è®¡ç®—è¯¥äº§å“åº”å¾—çš„äº§å‡ºï¼ˆä»·å€¼ â†’ ä»¶æ•°ï¼‰
                product_value = total_labor_output_value * (priority / total_priority)
                product_output = product_value / price if product_value > 0 else 0.0
                if product_output <= 0:
                    continue
                
                # å¢åŠ åº“å­˜
                old_amount = product.amount
                product.amount += product_output
                actual_output += product_output
                actual_output_value += product_value
                
                self.logger.debug(f"åŠ³åŠ¨åŠ›äº§å‡º: {product.name} ä¼˜å…ˆçº§ {priority:.2f}, å¢åŠ  {product_output:.2f}")
        else:
            # è¿™ç§æƒ…å†µç†è®ºä¸Šä¸åº”è¯¥å‘ç”Ÿï¼Œå› ä¸ºæ‰€æœ‰äº§å“éƒ½ä¼šæœ‰ä¼˜å…ˆçº§
            self.logger.warning(f"å…¬å¸ {firm_id} æ²¡æœ‰äº§å“å¯ä»¥åˆ†é…åŠ³åŠ¨åŠ›äº§å‡º")
        
        return actual_output, actual_output_value


    # =========================================================================
    # Production Statistics & GDP Calculation
    # =========================================================================
    def get_production_statistics(self, month: int) -> Dict[str, Any]:
        """
        è·å–ç”Ÿäº§ç»Ÿè®¡æ•°æ®
        """
        stats = {
            "total_companies": len([owner_id for owner_id in self.firm_id if owner_id in self.products and self.products[owner_id]]),
            "total_products": sum(len(products) for products in self.products.values()),
            "total_inventory": 0.0,
            "products_by_category": {},
            "low_stock_products": [],
            "high_stock_products": []
        }
        
        # ç»Ÿè®¡åº“å­˜æƒ…å†µ
        for owner_id, products in self.products.items():
            if owner_id in self.firm_id:
                for product in products:
                    stats["total_inventory"] += product.amount
                    
                    # æŒ‰åˆ†ç±»ç»Ÿè®¡
                    category = product.classification or "other"
                    if category not in stats["products_by_category"]:
                        stats["products_by_category"][category] = {"count": 0, "inventory": 0.0}
                    
                    stats["products_by_category"][category]["count"] += 1
                    stats["products_by_category"][category]["inventory"] += product.amount
                    
                    # è¯†åˆ«åº“å­˜å¼‚å¸¸çš„äº§å“
                    if product.amount < 5:
                        stats["low_stock_products"].append({
                            "name": product.name,
                            "amount": product.amount,
                            "owner": owner_id
                        })
                    elif product.amount > 80:
                        stats["high_stock_products"].append({
                            "name": product.name,
                            "amount": product.amount,
                            "owner": owner_id
                        })
        
        return stats

    async def update_tax_rates(self, income_tax_rate: float = None, vat_rate: float = None, corporate_tax_rate: float = None):
        """
        æ›´æ–°ç¨ç‡
        """
        if income_tax_rate is not None:
            self.income_tax_rate = income_tax_rate
        if vat_rate is not None:
            self.vat_rate = vat_rate
        if corporate_tax_rate is not None:
            self.corporate_tax_rate = corporate_tax_rate

        self.logger.info(f"ç¨ç‡å·²æ›´æ–°: income_tax_rate={self.income_tax_rate:.1%}, vat_rate={self.vat_rate:.1%}, corporate_tax_rate={self.corporate_tax_rate:.1%}")

# ======================== åˆ›æ–°ç³»ç»Ÿç›¸å…³æ–¹æ³• ========================


    # =========================================================================
    # Innovation System
    # =========================================================================
    def register_firm_innovation_config(self, firm, strategy: str, labor_productivity_factor: float, fund_share: float = 0.0):
        """
        æ³¨å†Œä¼ä¸šçš„åˆ›æ–°ç­–ç•¥

        Args:
            firm_id: ä¼ä¸šID
            strategy: åˆ›æ–°ç­–ç•¥ ("encouraged" æˆ– "suppressed")
            research_share: ç ”å‘æŠ•å…¥æ¯”ä¾‹ï¼ˆ0-1ä¹‹é—´çš„æµ®ç‚¹æ•°ï¼‰
        """
        # æ ¹æ®ä¼ä¸šçš„è¡Œä¸šï¼ˆmain_businessï¼‰è®¾ç½®æ¯›åˆ©ç‡
        # main_business é€šå¸¸å¯¹åº”å•†å“åˆ†ç±»ï¼ˆdaily_cateï¼‰
        profit_margin = self._get_profit_margin(firm.main_business)
        
        self.firm_innovation_config[firm.firm_id] = FirmInnovationConfig(
            firm_id=firm.firm_id,
            innovation_strategy=strategy,
            labor_productivity_factor=labor_productivity_factor,
            profit_margin=profit_margin,
            fund_share=fund_share
        )
        
        self.logger.info(f"âœ… ä¼ä¸š {firm.firm_id} åˆ›æ–°ç­–ç•¥: {strategy}, ç ”å‘æ¯”ä¾‹: {fund_share:.1%}, æ¯›åˆ©ç‡: {profit_margin:.1f}%")

    def query_firm_innovation_config(self, firm_id: str) -> FirmInnovationConfig:
        """
        æŸ¥è¯¢ä¼ä¸šçš„åˆ›æ–°ç­–ç•¥

        Returns:
            FirmInnovationConfig: FirmInnovationConfigå¯¹è±¡
        """
        if not self.enable_innovation_module:
            return None
        return self.firm_innovation_config.get(firm_id)

    def add_innovation_event(self, **kwargs):
        """
        æ·»åŠ åˆ›æ–°äº‹ä»¶è®°å½•

        Args:
            **kwargs: åˆ›æ–°äº‹ä»¶æ•°æ®
        """
        if not self.enable_innovation_module:
            return
        self.firm_innovation_events.append(FirmInnovationEvent.create(**kwargs))


    def query_all_firm_innovation_events(self) -> List[FirmInnovationEvent]:
        """
        æŸ¥è¯¢æ‰€æœ‰åˆ›æ–°äº‹ä»¶

        Returns:
            List: åˆ›æ–°äº‹ä»¶åˆ—è¡¨
        """
        if not self.enable_innovation_module:
            return []
        return self.firm_innovation_events


    def query_production_stats_by_month(self, month: int) -> Dict[str, Any]:
        """æŸ¥è¯¢å¹¶è¿”å›æŸä¸ªæœˆä»½çš„ç”Ÿäº§ç»Ÿè®¡ï¼ˆåŒ…å«åŠ³åŠ¨ä¸åˆ›æ–°ç»†èŠ‚ï¼‰ã€‚è‹¥æ— åˆ™è¿”å›ç©ºå­—å…¸ã€‚"""
        return self.production_stats_by_month.get(month, {})

    # ======================== GDP æ ¸ç®—ï¼ˆç”Ÿäº§æ³•/æ”¯å‡ºæ³•/æ”¶å…¥æ³•ï¼‰ ========================
    def _infer_firm_category(self, firm_id: str) -> Optional[str]:
        """
        å°è¯•ä»ä¼ä¸šåº“å­˜ä¸­æ¨æ–­ä¼ä¸šæ‰€å±å¤§ç±»ï¼ˆç”¨äºæ¯›åˆ©ç‡ï¼‰ã€‚
        è§„åˆ™ï¼šå–è¯¥ä¼ä¸šåº“å­˜ä¸­ç¬¬ä¸€ä¸ªå¸¦ classification çš„å•†å“ã€‚
        """
        try:
            for p in (self.products.get(firm_id, []) or []):
                cate = getattr(p, "classification", None)
                if cate:
                    return cate
        except Exception:
            pass
        return None

    def _get_firm_margin_rate(self, firm_id: str) -> float:
        """
        è·å–ä¼ä¸šæ¯›åˆ©ç‡ï¼ˆrateï¼‰ï¼Œé»˜è®¤ 25%ã€‚
        æ³¨æ„ï¼šæ¯›åˆ©ç‡å®šä¹‰ä¸º (å”®ä»·-æˆæœ¬)/å”®ä»·ï¼Œå› æ­¤ å”®ä»· = æˆæœ¬ / (1-æ¯›åˆ©ç‡)ã€‚
        """
        try:
            cate = self._infer_firm_category(firm_id) or "Unknown"
            margin_pct = float(self.category_profit_margins.get(cate, 25.0) or 25.0)
            margin_pct = max(0.0, min(80.0, margin_pct))
            return margin_pct / 100.0
        except Exception:
            return 0.25

    def calculate_nominal_gdp_and_health(self, month: int) -> Dict[str, Any]:
        """
        è®¡ç®—"åä¹‰GDP"åŠç³»ç»Ÿå¥åº·åº¦æŒ‡æ ‡
        
        åä¹‰GDPå®šä¹‰ï¼šå®¶åº­æ¶ˆè´¹ + å›ºæœ‰å¸‚åœºé”€å”®ï¼ˆå«ç¨ï¼Œåæ˜ å®é™…äº¤æ˜“è§„æ¨¡ï¼‰
        åŒæ—¶è¾“å‡ºç”Ÿäº§æ€»å€¼ä½œä¸ºå¯¹æ¯”æŒ‡æ ‡
        
        è¿™ä¸æ˜¯ä¸¥æ ¼çš„å›½æ°‘æ ¸ç®—GDPï¼Œè€Œæ˜¯ç³»ç»Ÿæ´»è·ƒåº¦/è§„æ¨¡çš„ä»£ç†æŒ‡æ ‡ã€‚
        åŒæ—¶æä¾›å¤šä¸ªç»´åº¦çš„å¥åº·åº¦æŒ‡æ ‡ç”¨äºè¯Šæ–­ç³»ç»Ÿè¿è¡ŒçŠ¶æ€ã€‚
        """
        # 1) ä¸»æŒ‡æ ‡ï¼šåä¹‰GDPï¼ˆäº¤æ˜“æ€»é¢æ³•ï¼‰
        sales_stats = self.collect_sales_statistics(month)
        household_sales_ex_tax = float(sum((s.get("household_revenue", 0.0) or 0.0) for s in (sales_stats or {}).values()) or 0.0)
        inherent_sales_ex_tax = float(sum((s.get("inherent_market_revenue", 0.0) or 0.0) for s in (sales_stats or {}).values()) or 0.0)
        gov_sales_ex_tax = float(sum((s.get("government_procurement_revenue", 0.0) or 0.0) for s in (sales_stats or {}).values()) or 0.0)
        total_sales_ex_tax = household_sales_ex_tax + inherent_sales_ex_tax + gov_sales_ex_tax

        transactions = self.tx_by_month.get(month)
        if transactions is None:
            transactions = self.tx_history
        
        # VAT
        vat_collected = 0.0
        for tx in transactions:
            if tx.month == month and tx.type == "consume_tax":
                vat_collected += float(tx.amount or 0.0)
        
        # åä¹‰GDPï¼ˆä¸»æŒ‡æ ‡ï¼‰= æ€»æ¶ˆè´¹ï¼ˆå«ç¨ï¼‰
        nominal_gdp_transaction = total_sales_ex_tax + vat_collected
        
        # 2) å¯¹æ¯”æŒ‡æ ‡ï¼šåä¹‰GDPï¼ˆç”Ÿäº§æ€»å€¼æ³•/ç”Ÿäº§ä¾§å£å¾„ï¼‰
        # âœ… ç»Ÿä¸€CDç”Ÿäº§åï¼Œç”Ÿäº§ç»Ÿè®¡ä¼šç›´æ¥ç»™å‡º total_output_valueï¼ˆæŒ‰å”®ä»·ä¼°å€¼çš„äº§å‡ºæ€»ä»·å€¼ï¼‰ã€‚
        ps = self.production_stats_by_month.get(month, {}) if hasattr(self, "production_stats_by_month") else {}
        total_production_cost = float(ps.get("total_production_cost", 0.0) or 0.0)

        total_output_value = float(ps.get("total_output_value", 0.0) or 0.0)
        if total_output_value > 0:
            nominal_gdp_production = total_output_value
            total_cost_based_production_value = total_output_value  # ä¿æŒå­—æ®µå«ä¹‰ï¼šç”Ÿäº§ä¾§æ€»ä»·å€¼
            total_labor_production_value = 0.0
        else:
            # å…¼å®¹æ—§ç»Ÿè®¡ï¼šè‹¥æ²¡æœ‰ total_output_valueï¼Œåˆ™å›é€€åˆ°â€œæˆæœ¬æ¨ç®— + åŠ³åŠ¨åŠ›ä»·å€¼â€
            total_labor_production_value = float(ps.get("total_labor_production_value", 0.0) or 0.0)
            total_cost_based_production_value = total_production_cost / (1 - 0.2) if total_production_cost > 0 else 0.0  # æ—§ï¼šå‡è®¾å¹³å‡æ¯›åˆ©ç‡20%
            nominal_gdp_production = total_cost_based_production_value + total_labor_production_value
        
        # ä¾›éœ€åŒ¹é…åº¦ï¼šäº¤æ˜“é¢ / ç”Ÿäº§æ€»å€¼ï¼ˆç†æƒ³å€¼æ¥è¿‘1.0ï¼‰
        supply_demand_ratio = (nominal_gdp_transaction / nominal_gdp_production) if nominal_gdp_production > 0 else 0.0
        
        # 3) æ”¶å…¥åˆ†é…
        total_wages = 0.0
        for tx in transactions:
            if tx.month == month and tx.type == "labor_payment":
                total_wages += float(tx.amount or 0.0)
        
        total_firm_revenue = total_sales_ex_tax
        total_firm_profit = total_firm_revenue - total_production_cost - total_wages  # ç®€åŒ–ä¼°ç®—
        
        # 4) åº“å­˜å¥åº·
        total_inventory_value = 0.0
        for owner_id, products in self.products.items():
            for p in products:
                total_inventory_value += float(getattr(p, "amount", 0.0) or 0.0) * float(getattr(p, "price", 0.0) or 0.0)
        inventory_to_gdp_ratio = (total_inventory_value / nominal_gdp_transaction) if nominal_gdp_transaction > 0 else 0.0
        
        # 5) è´¢æ”¿å¥åº·
        labor_tax_collected = 0.0
        fica_tax_collected = 0.0
        corporate_tax_collected = 0.0
        for tx in transactions:
            if tx.month == month:
                if tx.type == "labor_tax":
                    labor_tax_collected += float(tx.amount or 0.0)
                elif tx.type == "fica_tax":
                    fica_tax_collected += float(tx.amount or 0.0)
                elif tx.type == "corporate_tax":
                    corporate_tax_collected += float(tx.amount or 0.0)
        
        total_tax_revenue = vat_collected + labor_tax_collected + fica_tax_collected + corporate_tax_collected
        gov_balance = self.ledger.get("gov_main_simulation", type('obj', (), {'amount': 0.0})()).amount
        
        # 6) å°±ä¸šå¸‚åœº
        # âœ… ä¸ä¾èµ– self.households.employment_statusï¼ˆå¹¶è¡Œæ¶ˆè´¹/è½»é‡å¯¹è±¡åœºæ™¯ä¼šç¼ºå¤±ï¼‰ï¼Œæ”¹ç”¨äº¤æ˜“ä¸ laborhour å­˜é‡æ¨æ–­
        employed_count = 0
        for tx in transactions:
            if tx.month == month and tx.type == "labor_payment":
                employed_count += 1  # æ¯ç¬” labor_payment è¿‘ä¼¼å¯¹åº”ä¸€ä¸ªåŠ³åŠ¨åŠ›å•å…ƒï¼ˆhead/spouseï¼‰

        total_labor_force_units = 0
        try:
            for _hid, lhs in (self.laborhour or {}).items():
                total_labor_force_units += len(lhs or [])
        except Exception:
            total_labor_force_units = 0

        unemployed_count = max(0, int(total_labor_force_units) - int(employed_count))
        employment_rate = (float(employed_count) / float(total_labor_force_units)) if total_labor_force_units > 0 else 0.0
        average_wage = (total_wages / employed_count) if employed_count > 0 else 0.0
        
        # 7) ä»·æ ¼æ°´å¹³ï¼ˆç®€åŒ–ï¼šæ‰€æœ‰äº§å“çš„åŠ æƒå¹³å‡ä»·æ ¼ï¼‰
        total_price_weighted = 0.0
        total_quantity = 0.0
        for owner_id, products in self.products.items():
            for p in products:
                qty = float(getattr(p, "amount", 0.0) or 0.0)
                price = float(getattr(p, "price", 0.0) or 0.0)
                total_price_weighted += price * qty
                total_quantity += qty
        average_price_level = (total_price_weighted / total_quantity) if total_quantity > 0 else 0.0
        
        return {
            "month": month,
            "nominal_gdp": nominal_gdp_transaction,  # ä¸»æŒ‡æ ‡ï¼šäº¤æ˜“æ€»é¢æ³•
            "nominal_gdp_alternative": nominal_gdp_production,  # å¯¹æ¯”æŒ‡æ ‡ï¼šç”Ÿäº§æ€»å€¼æ³•
            "supply_demand_ratio": supply_demand_ratio,  # ä¾›éœ€åŒ¹é…åº¦ï¼ˆç†æƒ³å€¼~1.0ï¼‰
            "gdp_components": {
                "household_consumption": household_sales_ex_tax + (household_sales_ex_tax * self.vat_rate),
                "government_procurement": gov_sales_ex_tax,  # ä¸å«ç¨ï¼ˆæ”¿åºœé‡‡è´­ä¸ç¼´VATï¼‰
                "inherent_market_sales": inherent_sales_ex_tax + (inherent_sales_ex_tax * self.vat_rate),
                "vat_collected": vat_collected
            },
            "production_metrics": {
                "total_production_value": nominal_gdp_production,  # ç”Ÿäº§æ€»å€¼æ³•çš„GDP
                "cost_based_production_value": total_cost_based_production_value,  # æˆæœ¬ç”Ÿäº§éƒ¨åˆ†
                "total_production_cost": total_production_cost,
                "total_labor_production": total_labor_production_value
            },
            "income_distribution": {
                "total_wages": total_wages,
                "total_firm_profit": total_firm_profit,
                "wage_share": (total_wages / nominal_gdp_transaction) if nominal_gdp_transaction > 0 else 0.0,
                "profit_share": (total_firm_profit / nominal_gdp_transaction) if nominal_gdp_transaction > 0 else 0.0
            },
            "inventory_health": {
                "total_inventory_value": total_inventory_value,
                "inventory_to_gdp_ratio": inventory_to_gdp_ratio
            },
            "fiscal_health": {
                "total_tax_revenue": total_tax_revenue,
                "vat_revenue": vat_collected,
                "labor_tax_revenue": labor_tax_collected,
                "fica_tax_revenue": fica_tax_collected,
                "corporate_tax_revenue": corporate_tax_collected,
                "government_balance": gov_balance
            },
            "labor_market": {
                "employment_rate": employment_rate,
                "employed": employed_count,
                "unemployed": unemployed_count,
                "average_monthly_wage": average_wage
            },
            "price_level": {
                "average_price": average_price_level
            }
        }

    def calculate_monthly_gdp(self, month: int, production_stats: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        è®¡ç®—æœˆåº¦ GDPï¼ˆç”Ÿäº§æ³• / æ”¯å‡ºæ³• / æ”¶å…¥æ³•ï¼‰ï¼Œå¹¶ç»™å‡ºåˆ†é¡¹ã€‚
        
        âš ï¸ æ³¨æ„ï¼šæ­¤æ–¹æ³•è®¡ç®—çš„ä¸‰ç§GDPæ–¹æ³•åœ¨æ•°å­¦ä¸Šæ˜¯æ’ç­‰çš„ï¼ˆç”±äºé‡‡ç”¨åŒä¸€å¥—æ•°æ®æºï¼‰ï¼Œ
        ä¸ä»£è¡¨çœŸå®çš„å›½æ°‘æ ¸ç®—ã€‚å¦‚éœ€ç³»ç»Ÿå¥åº·åº¦æŒ‡æ ‡ï¼Œå»ºè®®ä½¿ç”¨ calculate_nominal_gdp_and_health()

        - äº§å“ç¨ï¼šæŒ‰"æ€»æ¶ˆè´¹ï¼ˆå®¶åº­+å›ºæœ‰å¸‚åœº/æ”¿åºœç­‰è´­ä¹°ï¼Œå‡ä¸ºä¸å«ç¨é‡‘é¢ï¼‰Ã— VATç¨ç‡"ä¼°ç®—ï¼›
                 åŒæ—¶ä¹Ÿä¼šå°è¯•ä» tx_history çš„ consume_tax å–"å®é™…VAT"ï¼Œè‹¥å­˜åœ¨åˆ™ä¼˜å…ˆä½¿ç”¨ã€‚
        - ç”Ÿäº§æ€»ä»·å€¼ï¼ˆoutputï¼‰ï¼šä¼˜å…ˆä½¿ç”¨ç”Ÿäº§é˜¶æ®µç›´æ¥ç»Ÿè®¡çš„â€œäº§å‡ºæ€»ä»·å€¼â€ï¼ˆä¾‹å¦‚ç»Ÿä¸€CDç”Ÿäº§çš„ total_output_value / firm_production_valueï¼‰ï¼›
          è‹¥ç¼ºå¤±æ‰å›é€€ç”¨"æŠ•å…¥æˆæœ¬/ (1-æ¯›åˆ©ç‡)"ç²—ç•¥ä¼°ç®—ï¼ˆä»…ç”¨äºå…¼å®¹æ—§ç»Ÿè®¡ï¼‰ã€‚
        - ä¸­é—´æ¶ˆè€—ï¼šåŸºç¡€ç”Ÿäº§æŠ•å…¥æˆæœ¬ï¼ˆproduction_costï¼‰ã€‚
        - åº“å­˜æŠ•èµ„ï¼šoutput - salesï¼ˆsales ä¸ºä¸å«ç¨é”€å”®é¢ï¼Œå«å®¶åº­+å›ºæœ‰å¸‚åœºç­‰ï¼‰ã€‚
        - æ”¶å…¥æ³•ï¼šç¨é‡‘ + å·¥èµ„ + è¥ä¸šç›ˆä½™ï¼Œå…¶ä¸­è¥ä¸šç›ˆä½™ = (output - ä¸­é—´æ¶ˆè€—) - å·¥èµ„ã€‚
        """
        ps = production_stats
        if ps is None:
            ps = self.production_stats_by_month.get(month, {}) if hasattr(self, "production_stats_by_month") else {}
        ps = ps or {}

        # 1) é”€å”®/æ¶ˆè´¹ï¼ˆä¸å«ç¨ï¼‰
        sales_stats = self.collect_sales_statistics(month)
        total_sales_ex_tax = float(sum((s.get("revenue", 0.0) or 0.0) for s in (sales_stats or {}).values()) or 0.0)
        household_sales_ex_tax = float(sum((s.get("household_revenue", 0.0) or 0.0) for s in (sales_stats or {}).values()) or 0.0)
        inherent_sales_ex_tax = float(sum((s.get("inherent_market_revenue", 0.0) or 0.0) for s in (sales_stats or {}).values()) or 0.0)

        transactions = self.tx_by_month.get(month)
        if transactions is None:
            transactions = self.tx_history

        # 2) VATï¼ˆäº§å“ç¨ï¼‰
        vat_rate = float(self.vat_rate or 0.0)
        vat_estimated = total_sales_ex_tax * vat_rate
        vat_actual = 0.0
        try:
            for tx in transactions:
                if tx.month == month and tx.type == "consume_tax":
                    vat_actual += float(tx.amount or 0.0)
        except Exception:
            vat_actual = 0.0
        product_taxes_vat = vat_actual if vat_actual > 0 else vat_estimated

        # 3) ç”Ÿäº§ï¼šåŸºç¡€ç”Ÿäº§æˆæœ¬ã€åŸºç¡€ç”Ÿäº§æ€»ä»·å€¼
        firm_cost = (ps.get("firm_production_cost", {}) or {})
        firm_value_reported = (ps.get("firm_production_value", {}) or {})
        total_base_cost = float(ps.get("total_production_cost", 0.0) or sum((float(v or 0.0) for v in firm_cost.values())) or 0.0)

        # ä¼˜å…ˆï¼šç»Ÿä¸€CDç”Ÿäº§ä¼šæä¾› total_output_valueï¼›å¦åˆ™ç”¨ firm_production_value èšåˆ
        total_output_value_reported = float(ps.get("total_output_value", 0.0) or 0.0)
        total_base_value_reported = (
            total_output_value_reported
            if total_output_value_reported > 0
            else float(sum((float(v or 0.0) for v in firm_value_reported.values())) or 0.0)
        )

        # å…¼å®¹æ—§ç»Ÿè®¡ï¼šè‹¥ç¼ºå¤±äº§å‡ºä»·å€¼ï¼Œå†ç”¨â€œæˆæœ¬/(1-margin)â€ä¼°ç®—ï¼ˆæœ€åå…œåº•ï¼‰
        base_value_inferred_from_cost_margin = {}
        total_base_value_inferred_from_cost_margin = 0.0
        if total_base_value_reported <= 1e-12:
            try:
                for cid, c in firm_cost.items():
                    cost = float(c or 0.0)
                    m = self._get_firm_margin_rate(str(cid))
                    denom = 1.0 - float(m)
                    value = (cost / denom) if denom > 1e-9 else 0.0
                    base_value_inferred_from_cost_margin[str(cid)] = value
                    total_base_value_inferred_from_cost_margin += value
            except Exception:
                total_base_value_inferred_from_cost_margin = 0.0

        total_base_value_used = total_base_value_reported if total_base_value_reported > 0 else total_base_value_inferred_from_cost_margin

        # 4) åŠ³åŠ¨åŠ›ç”Ÿäº§æ€»ä»·å€¼ï¼ˆä¿æŒç°æœ‰é€»è¾‘ï¼Œä¸æ”¹ï¼‰
        total_labor_value = float(ps.get("total_labor_production_value", 0.0) or 0.0)
        if total_labor_value <= 0:
            # å…œåº•ï¼šæŒ‰ firm ç»´åº¦ç´¯åŠ 
            try:
                total_labor_value = float(sum((float(v or 0.0) for v in (ps.get("firm_labor_production_value", {}) or {}).values())) or 0.0)
            except Exception:
                total_labor_value = 0.0

        # 5) Output / ä¸­é—´æ¶ˆè€— / å¢åŠ å€¼
        output_value_total = float(total_base_value_used + total_labor_value)
        intermediate_consumption = float(total_base_cost)  # ä½ çš„è®¾å®šï¼šä¸­é—´æ¶ˆè€—=ç”Ÿäº§æŠ•å…¥æˆæœ¬
        gross_value_added = float(output_value_total - intermediate_consumption)

        # 6) åº“å­˜æŠ•èµ„ï¼ˆä½ çš„è®¾å®šï¼šäº§å‡ºæ€»ä»·å€¼ - é”€å”®é¢ï¼‰
        inventory_investment = float(output_value_total - total_sales_ex_tax)

        # 7) å·¥èµ„ï¼ˆä¼˜å…ˆç”¨ tx_history çš„ labor_paymentï¼›å¦åˆ™ç”¨ç”Ÿäº§ç»Ÿè®¡é‡Œçš„ total_wage_expensesï¼‰
        wages_from_stats = float(ps.get("total_wage_expenses", 0.0) or 0.0) # ç¨å‰
        wages_from_tx = 0.0
        try:
            for tx in transactions:
                if tx.month == month and tx.type == "labor_payment":
                    wages_from_tx += float(tx.amount or 0.0) # ç¨å
        except Exception:
            wages_from_tx = 0.0
        wages_used = wages_from_tx if wages_from_tx > 0 else wages_from_stats

        # 8) è¥ä¸šç›ˆä½™ï¼ˆOperating surplusï¼‰
        operating_surplus = float(gross_value_added - wages_used)

        # 9) ä¸‰ç§ GDPï¼ˆæŒ‰åŒä¸€å¥—åˆ†é¡¹æ„é€ ï¼Œç†è®ºä¸Šåº”ä¸€è‡´ï¼Œä»…æœ‰æµ®ç‚¹/å£å¾„å·®ï¼‰
        gdp_production = float(gross_value_added + product_taxes_vat)
        gdp_expenditure = float((total_sales_ex_tax + product_taxes_vat) + inventory_investment - intermediate_consumption)
        gdp_income = float(product_taxes_vat + wages_used + operating_surplus)

        # 10) ç»Ÿè®¡è¯¯å·®
        max_gdp = max(gdp_production, gdp_expenditure, gdp_income)
        min_gdp = min(gdp_production, gdp_expenditure, gdp_income)

        return {
            "month": month,
            "rates": {
                "vat_rate": vat_rate,
            },
            "consumption": {
                "total_sales_ex_tax": total_sales_ex_tax,
                "household_sales_ex_tax": household_sales_ex_tax,
                "inherent_market_sales_ex_tax": inherent_sales_ex_tax,
            },
            "taxes": {
                "vat_estimated_from_sales": vat_estimated,
                "vat_actual_from_tx": vat_actual,
                "vat_used": product_taxes_vat,
            },
            "production": {
                "base_production_cost": total_base_cost,
                "base_production_value_by_margin": total_base_value_used,
                "base_production_value_reported": total_base_value_reported,
                "base_production_value_inferred_from_cost_margin": total_base_value_inferred_from_cost_margin,
                "base_production_value_source": (
                    "reported" if total_base_value_reported > 0 else "inferred_from_cost_margin"
                ),
                "labor_production_value": total_labor_value,
                "output_value_total": output_value_total,
            },
            "accounts": {
                "intermediate_consumption": intermediate_consumption,
                "gross_value_added": gross_value_added,
                "inventory_investment": inventory_investment,
                "wages_from_stats": wages_from_stats,
                "wages_from_tx": wages_from_tx,
                "wages_used": wages_used,
                "operating_surplus": operating_surplus,
            },
            "gdp": {
                "production_approach": gdp_production,
                "expenditure_approach": gdp_expenditure,
                "income_approach": gdp_income,
                "statistical_discrepancy": {
                    "max_minus_min": float(max_gdp - min_gdp),
                    "production_minus_expenditure": float(gdp_production - gdp_expenditure),
                    "production_minus_income": float(gdp_production - gdp_income),
                    "expenditure_minus_income": float(gdp_expenditure - gdp_income),
                },
            },
        }
